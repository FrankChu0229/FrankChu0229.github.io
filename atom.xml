<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Frank Chu</title>
  <icon>https://www.gravatar.com/avatar/7c04e9129318ea2b45bdf06f71529116</icon>
  <subtitle>The world need dreamers who do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://frankchu0229.github.io/"/>
  <updated>2019-05-19T07:42:36.752Z</updated>
  <id>http://frankchu0229.github.io/</id>
  
  <author>
    <name>Frank Chu</name>
    <email>chushb@shanghaitech.edu.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hive HQL Summary</title>
    <link href="http://frankchu0229.github.io/2019/05/19/hive-summary/"/>
    <id>http://frankchu0229.github.io/2019/05/19/hive-summary/</id>
    <published>2019-05-19T07:11:39.000Z</published>
    <updated>2019-05-19T07:42:36.752Z</updated>
    
    <content type="html"><![CDATA[<p>在企业中，和线上数据打交道的最简单方式可能就是使用如hive，impala等平台了；用户只需会写SQL语句即可。在hive平台上，与它对应的是HQL语句，HQL基本支持SQL的全部操作，除此之外，他还支持<code>array</code>, <code>struct</code>, <code>map</code>等数据结构，具有更强大的能力。</p><h2 id="通过SQL方式在hive上进行查询等操作"><a href="#通过SQL方式在hive上进行查询等操作" class="headerlink" title="通过SQL方式在hive上进行查询等操作"></a>通过SQL方式在hive上进行查询等操作</h2><table><thead><tr><th><strong>Function</strong></th><th><strong>MySQL</strong></th><th><strong>Hive</strong></th></tr></thead><tbody><tr><td>Retrieving Information (General)</td><td><code>SELECT from_columns FROM table WHERE conditions;</code></td><td><code>SELECT from_columns FROM table WHERE conditions;</code></td></tr><tr><td>Retrieving All Values</td><td><code>SELECT * FROM table;</code></td><td><code>SELECT * FROM table;</code></td></tr><tr><td>Retrieving Some Values</td><td><code>SELECT * FROM table WHERE rec_name = &quot;value&quot;;</code></td><td><code>SELECT * FROM table WHERE rec_name = &quot;value&quot;;</code></td></tr><tr><td>Retrieving With Multiple Criteria</td><td><code>SELECT * FROM TABLE WHERE rec1= &quot;value1&quot; AND rec2 = &quot;value2&quot;;</code></td><td><code>SELECT * FROM TABLE WHERE rec1 =&quot;value1&quot; AND rec2 = &quot;value2&quot;;</code></td></tr><tr><td>Retrieving Specific Columns</td><td><code>SELECT column_name FROM table;</code></td><td><code>SELECT column_name FROM table;</code></td></tr><tr><td>Retrieving Unique Output</td><td><code>SELECT DISTINCT column_name FROM table;</code></td><td><code>SELECT DISTINCT column_name FROM table;</code></td></tr><tr><td>Sorting</td><td><code>SELECT col1, col2 FROM table ORDER BY col2;</code></td><td><code>SELECT col1, col2 FROM table ORDER BY col2;</code></td></tr><tr><td>Sorting Reverse</td><td><code>SELECT col1, col2 FROM table ORDER BY col2 DESC;</code></td><td><code>SELECT col1, col2 FROM table ORDER BY col2 DESC;</code></td></tr><tr><td>Counting Rows</td><td><code>SELECT COUNT(*) FROM table;</code></td><td><code>SELECT COUNT(*) FROM table;</code></td></tr><tr><td>Grouping With Counting</td><td><code>SELECT owner, COUNT(*) FROM table GROUP BY owner;</code></td><td><code>SELECT owner, COUNT(*) FROM table GROUP BY owner;</code></td></tr><tr><td>Maximum Value</td><td><code>SELECT MAX(col_name) AS label FROM table;</code></td><td><code>SELECT MAX(col_name) AS label FROM table;</code></td></tr><tr><td>Selecting from multiple tables (Join same table using alias w/”AS”)</td><td><code>SELECT pet.name, comment FROM pet, event WHERE pet.name =event.name;</code></td><td><code>SELECT pet.name, comment FROM pet JOIN event ON (pet.name =event.name)</code></td></tr></tbody></table><h2 id="处理hive表中的array-struct等表中数据"><a href="#处理hive表中的array-struct等表中数据" class="headerlink" title="处理hive表中的array, struct等表中数据"></a>处理hive表中的<code>array</code>, <code>struct</code>等表中数据</h2><p>例如，从一个trade表中，select相关的订单数据，并按照spu_id进行groupby和sum。 这里使用lateral view explode(t.order_list)将array进行展开并和已有的表进行join。<br>这里还需注意的一点是，展开后的array是struct结构，该struct结构包含<code>spu_id</code>, <code>item_count</code>, <code>payment</code>字段，如果直接按照struct.field进行groupby和sum会出错，所以这里使用()构建了一个临时表，在对临时表进行groupby和sum操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">INSERT OVERWRITE DIRECTORY &apos;/user/XXX/XXX&apos;</div><div class="line">select store_id, spu_id, sum(item_count) as item_sum, sum(payment) as payment_sum from</div><div class="line">(select t.store_id store_id, </div><div class="line">orderTable.orderTable.spu_id as spu_id, </div><div class="line">orderTable.orderTable.item_count as item_count,</div><div class="line">orderTable.orderTable.payment as payment </div><div class="line">from trade as t </div><div class="line">lateral view explode(t.order_list) orderTable as orderTable</div><div class="line">where t.year = 2019 and (t.month = 5 or t.month=4 or t.month=3)</div><div class="line">and t.store_id in ($&#123;stores&#125;)) as tmp</div><div class="line">group by store_id, spu_id;</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://hortonworks.com/blog/hive-cheat-sheet-for-sql-users/" target="_blank" rel="external">HQL Cheat Sheet</a></li><li><a href="https://cwiki.apache.org/confluence/display/Hive/Home" target="_blank" rel="external">HQL Wiki</a></li></ul>]]></content>
    
    <summary type="html">
    
      Hive HQL Summary
    
    </summary>
    
      <category term="Data Engineering" scheme="http://frankchu0229.github.io/categories/Data-Engineering/"/>
    
    
      <category term="big data" scheme="http://frankchu0229.github.io/tags/big-data/"/>
    
      <category term="data engineering" scheme="http://frankchu0229.github.io/tags/data-engineering/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-8</title>
    <link href="http://frankchu0229.github.io/2019/01/07/java8-functional-programming8/"/>
    <id>http://frankchu0229.github.io/2019/01/07/java8-functional-programming8/</id>
    <published>2019-01-07T12:05:37.000Z</published>
    <updated>2019-04-07T12:08:58.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Lambda表达式编写并发程序"><a href="#使用Lambda表达式编写并发程序" class="headerlink" title="使用Lambda表达式编写并发程序"></a>使用Lambda表达式编写并发程序</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-7</title>
    <link href="http://frankchu0229.github.io/2018/11/04/java8-functional-programming7/"/>
    <id>http://frankchu0229.github.io/2018/11/04/java8-functional-programming7/</id>
    <published>2018-11-04T09:41:44.000Z</published>
    <updated>2019-04-10T03:17:44.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计和架构的原则"><a href="#设计和架构的原则" class="headerlink" title="设计和架构的原则"></a>设计和架构的原则</h1><p><code>设计原则</code>是编写代码时需要遵守的基本原则；<code>设计模式</code>可以看做是解决某种通用问题的模板，是对某一类问题实现方式的best practice总结。在一些设计模式的书籍中，例如<code>Head First 设计模式</code>，书中的例子还是基于java7或者更早之前的java来实现的。java8中引入lambda表达式之后，一些设计模式的实现可以变得更好，更简单。</p><p>下面先介绍基本的设计原则和一些常见的设计模式，然后展示如何通过lambda表达式来使得一些设计模式的编写更加简单。</p><h2 id="面向对象三要素"><a href="#面向对象三要素" class="headerlink" title="面向对象三要素"></a>面向对象三要素</h2><h3 id="集成"><a href="#集成" class="headerlink" title="集成"></a>集成</h3><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li><li><a href="https://java-design-patterns.com/" target="_blank" rel="external">java design patterns</a></li><li><a href="http://cyc2018.gitee.io/cs-notes/#/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F?id=%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" target="_blank" rel="external">cs-notes</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-6</title>
    <link href="http://frankchu0229.github.io/2018/10/28/java8-functional-programming6/"/>
    <id>http://frankchu0229.github.io/2018/10/28/java8-functional-programming6/</id>
    <published>2018-10-28T14:23:34.000Z</published>
    <updated>2018-11-04T09:43:25.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试、调试和重构"><a href="#测试、调试和重构" class="headerlink" title="测试、调试和重构"></a>测试、调试和重构</h2><p>本部分侧重于lambda表达式的测试，调试以及将已有代码重构为lambda表达式的形式。</p><h3 id="利用lambda表达式进行重构"><a href="#利用lambda表达式进行重构" class="headerlink" title="利用lambda表达式进行重构"></a>利用lambda表达式进行重构</h3><p>在之前的例子中，我们主要使用lambda表达式对集合操作进行重构，这里我们更深入一些，看看什么时候适合将我们的代码lambda化。</p><h4 id="进行行为的传递"><a href="#进行行为的传递" class="headerlink" title="进行行为的传递"></a>进行行为的传递</h4><p>和面向对象编程相比，lambda表达式是对行为的抽象，可以进行行为的传递；有很多模式多类似，但是行为有所不同，面向对象编程是对数据的抽象，不是很好能解决这个问题，例如，</p><p>在一个Order类中，我们想对用户购买的专辑做一些统计, 命令式的实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public long countRunningTime() &#123;</div><div class="line">    long count = 0;</div><div class="line">    for (Album album : this.albums) &#123;</div><div class="line">    for (Track track : album.getTrackList()) &#123;</div><div class="line">            count += album.getLength();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countMusicians() &#123;</div><div class="line">    long count = 0;</div><div class="line">    for (Album album : this.albums) &#123;</div><div class="line">         count += album.getMusicianList().size();</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countTracks() &#123;</div><div class="line">    long count = 0;</div><div class="line">    for (Album album : this.albums) &#123;</div><div class="line">        count += album.getTrackList().size();</div><div class="line">    &#125;</div><div class="line">    return count;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以使用集合的stream进行一定的重构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public long countRunningTime() &#123;</div><div class="line">    return this.albums.stream().mapToLong(album -&gt; album.getTrackList().stream().mapToLong(track -&gt; track.getLength()).sum()).sum();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countMusicians() &#123;</div><div class="line">    return this.albums.stream().mapToLong(album -&gt; album.getMusicianList().size()).sum();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countTracks() &#123;</div><div class="line">    return this.albums.stream().mapToLong(album -&gt; album.getTrackList().size()).sum();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>进而，我们可以将行为进行抽象，使用<code>ToLongFunction</code>函数式接口，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public long countFeature(ToLongFunction function) &#123;</div><div class="line">    return this.albums.stream().mapToLong(function).sum();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countRunningTime() &#123;</div><div class="line">    return countFeature(album -&gt; album.getTrackList().stream().mapToLong(track -&gt; track.getLength()).sum());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countMusicians() &#123;</div><div class="line">    return countFeature(album -&gt; album.getMusicianList().size());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public long countTracks() &#123;</div><div class="line">    return countFeature(album -&gt; album.getTrackList().size());</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="使用lambda表达式代替匿名内部类"><a href="#使用lambda表达式代替匿名内部类" class="headerlink" title="使用lambda表达式代替匿名内部类"></a>使用lambda表达式代替匿名内部类</h4><p>和内部匿名类相比，lambda表达式可读性更好，代码实现更简洁。例如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ThreadLocal&lt;Album&gt; thisAlbum = new ThreadLocal&lt;Album&gt;() &#123;</div><div class="line">    @Override protected Album initValue() &#123;</div><div class="line">        return database.lookupCurrentAlbum();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">ThreadLocal&lt;Album&gt; thisAlbum = ThreadLocal.withInitial(() -&gt; database.lookupCurrentAlbum());</div></pre></td></tr></table></figure><h4 id="使用java8内置类库中的新接口"><a href="#使用java8内置类库中的新接口" class="headerlink" title="使用java8内置类库中的新接口"></a>使用java8内置类库中的新接口</h4><p>在<a href="http://frankchu.tech/2018/10/15/java8-functional-programming4/" target="_blank" rel="external">这里</a>我们提到了用java8中的<code>computeIfPresent()</code>, <code>computeIfAbsent()</code>, <code>compute()</code>, <code>putIfAbsent()</code>等简化对map的操作。</p><h3 id="lambda表达式的单元测试"><a href="#lambda表达式的单元测试" class="headerlink" title="lambda表达式的单元测试"></a>lambda表达式的单元测试</h3><p>通常在单元测试中，我们调用一个方法，构造可能的输入参数，看输出是否符合我们预期的情况。但是lambda表达式没有名字，无法进行直接的测试，有几种解决方式：</p><ul><li>将lambda表达式代码copy到单元测试中：这种不是对真正实现的测试，有可能真正实现的代码改变了，但是单元测试还是通过的。</li><li>对lamnda表达式所在方法进行测试，但是这样测试的是该方法，不是对lambda表达式的直接测试。</li></ul><p>正确的做法是使用<code>方法引用</code>，任何lambda表达式都能被表示称普通方法，例如， 在一个将首字母变为大写的代码中，我们可以看到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public static List&lt;String&gt; elementFirstToUpperCase(List&lt;String&gt; words) &#123;</div><div class="line">return words.stream().map(word -&gt; &#123;</div><div class="line">  char firstChar = Character.toUpperCase(word.charAt(0));</div><div class="line">  return firstChar + word.substring(1);</div><div class="line">&#125;).collect(Collectors.toList());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static String firstToUpperCase(String word) &#123;</div><div class="line">  char firstChar = Character.toUpperCase(word.charAt(0));</div><div class="line">  return firstChar + word.substring(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static List&lt;String&gt; elementFirstToUpperCase(List&lt;String&gt; words) &#123;</div><div class="line">  return words.stream().map(Testing::firstToUpperCase).collect(Collectors.toList());</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static String firstToUpperCase(String word) &#123;</div><div class="line">  char firstChar = Character.toUpperCase(word.charAt(0));</div><div class="line">  return firstChar + word.substring(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Test</div><div class="line">public void test() &#123;</div><div class="line">    String word = &quot;ab&quot;;</div><div class="line">    String result = Testing.firstToUpperCase(word);</div><div class="line">    assertEquals(word, &quot;Ab&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="Stream的调试"><a href="#Stream的调试" class="headerlink" title="Stream的调试"></a>Stream的调试</h3><p>我们在前几篇blog中提到过，stream是<code>内部迭代</code>, 而且像<code>filter</code>, <code>map</code>等操作都是惰性求值，对我们<code>调试</code>，<code>打断点</code>，<code>打log</code>都带来了一定挑战。幸运的是我们可以使用<code>peek</code>方法查看stream中的每一个值，同时还能继续操作流，同时我们还能在<code>peek</code>处加断点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; list = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)</div><div class="line">    .map(s -&gt; s.toUpperCase())</div><div class="line">    .peek(s -&gt; System.out.println(s))</div><div class="line">    .collect(Collectors.toList());</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-5</title>
    <link href="http://frankchu0229.github.io/2018/10/17/java8-functional-programming5/"/>
    <id>http://frankchu0229.github.io/2018/10/17/java8-functional-programming5/</id>
    <published>2018-10-17T15:17:37.000Z</published>
    <updated>2018-10-28T14:55:22.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据并行化"><a href="#数据并行化" class="headerlink" title="数据并行化"></a>数据并行化</h2><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发是指具有多任务处理的能力，多任务共享时间段，但不一定是同时；并行是指多个任务在同时进行处理；两者的区别主要还是是否为<code>同时</code>。知乎中很好的一个回答</p><p><strong>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</strong></p><p>现在，计算机处理器主频频率增长速度已经很缓慢了，现代处理器主要为多核处理器，例如带有32核，64核等处理器的服务器机器已经比较常见了。这种处理器的变化影响了我们软件设计的方式，如何利用好多核处理器来加速我们的程序设计也成为了越来越多人关心的话题。</p><h3 id="流的并行化操作"><a href="#流的并行化操作" class="headerlink" title="流的并行化操作"></a>流的并行化操作</h3><p>如果已经是一个stream了，我们可以通过<code>parallel()</code>方法来拥有并行化的能力，如果是一个Collection，我们可以通过<code>parallelStream()</code>的方式拥有并行化的能力。</p><p>例如，之前我们用stream对数据操作的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">return albums.stream().mapToInt(Album::getLength).sum()</div></pre></td></tr></table></figure><p>现在可以通过parallelStream获得并行化能力</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">return albums.parallenStream().mapToInt(Album::getLength).sum()</div></pre></td></tr></table></figure><p>从上面的代码中，我们可以很轻松的将串行的stream变为parallelStream，即可拥有并行处理的能力，但是前提是代码写的需要符合规定，即需要遵守一些规则，否则并行化处理可能会和预想中的结果不一致。</p><ul><li>reduce的操作，初始值需要为<code>组合函数的恒等值</code>，例如用reduce求知时，(acc, element) -&gt; acc + element 则初始值必须为0； 相应的若为乘法，则初始值为1</li><li>reduce操作的另一个限制是<code>组合操作</code>必须符合<code>结合律</code>, 意味着只要序列的值不变，组合操作的顺序不重要。</li><li>要避免<code>持有锁</code>, stream内部会做相应的同步操作，没有必要自己加锁</li></ul><h3 id="并行化性能"><a href="#并行化性能" class="headerlink" title="并行化性能"></a>并行化性能</h3><p>并行化操作parallelStream在数据量小的时候不一定会比串行化操作stream的速度要好，在数据量大的时候，并行化处理速度会好很多。</p><p>影响并行化操作的性能主要由以下几方面：</p><ul><li><code>数据大小</code></li><li><code>数据源结构</code>, 支持随机读取的数据结构如ArrayList，数组，IntStream.range等可以被任意分解，在并行操作中效果最好；像hashset，treeset这些数据结构，不易被公平分解，但是大多数是可被分解的，性能一般；像LinkedList对半分解很难，还有像Streams.iterate, BufferReader.lines长度未知，因此很难预测在哪里分解，有时可能要O(N)的复杂度才能将他们对半分解，性能较差。</li><li><code>装箱</code>， 基本类型比装箱类型速度要快</li><li><code>cpu核的数量</code></li><li><code>单元处理开销</code>， 在底层，并行流使用了fork/join框架，递归式的分解问题，然后每段并行执行，最终由join合并结果，返回最后的值。因此并行时间主要消耗在分解合并与并行执行上，只有并行执行的时间远大于分解合并的时间，并行操作性能提升才会越明显。</li><li><code>有无状态</code>, 像<code>map</code>, <code>filter</code>, <code>flatMap</code>等操作属于无状态的，<code>sort</code>, <code>distinct</code>, <code>limit</code>是有状态的，无状态会比有状态获得更好的获得并行性能。 </li></ul><h3 id="并行化数组操作"><a href="#并行化数组操作" class="headerlink" title="并行化数组操作"></a>并行化数组操作</h3><p>Java8中也引入了一些对数组的并行操作, 这次操作都在<code>Arrays</code>中</p><ul><li><p><code>parallelPrefix</code> 任意给定一个函数，计算数组的和(可以为任意的BinaryOperator)</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">double sums = new double[100];</div><div class="line">Arrays.parallelSetAll(sums, i -&gt; i);</div><div class="line">Arrays.parallelPrefix(sums, Double::sum) // 得到[0,1,3,6] ... 即[0,1,2,3]的相加。</div></pre></td></tr></table></figure></li><li><p><code>parallelSetAll</code> 使用lambda表达式更新数组元素 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">double values = new double[100]</div><div class="line">Arrays.parallelSetAll(values, i -&gt; i) // 为每个数组元素的值设定为它的下标的值，i为下标</div></pre></td></tr></table></figure></li><li><p><code>parallelSort</code> 并行化对数组排序</p></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li><li><a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">Answers From Zhihu</a></li><li><a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="external">Fork/Join</a></li><li><a href="http://www.importnew.com/27334.html" target="_blank" rel="external">Fork/Join</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Junit Summary</title>
    <link href="http://frankchu0229.github.io/2018/10/17/junit-summary/"/>
    <id>http://frankchu0229.github.io/2018/10/17/junit-summary/</id>
    <published>2018-10-17T06:47:03.000Z</published>
    <updated>2018-10-17T06:53:15.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AssertThat"><a href="#AssertThat" class="headerlink" title="AssertThat"></a>AssertThat</h2><p>最近发现了junit中，可以使用<code>AssertThat</code>, 使得测试更加方便了。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://blog.csdn.net/mayanyun2013/article/details/51566749" target="_blank" rel="external">Jnuit AssertThat</a></li></ul>]]></content>
    
    <summary type="html">
    
      Junit Test Summary.
    
    </summary>
    
      <category term="junit" scheme="http://frankchu0229.github.io/categories/junit/"/>
    
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="test" scheme="http://frankchu0229.github.io/tags/test/"/>
    
      <category term="junit" scheme="http://frankchu0229.github.io/tags/junit/"/>
    
  </entry>
  
  <entry>
    <title>Relation Extraction Summary</title>
    <link href="http://frankchu0229.github.io/2018/10/15/relation-extraction-summary/"/>
    <id>http://frankchu0229.github.io/2018/10/15/relation-extraction-summary/</id>
    <published>2018-10-15T08:49:13.000Z</published>
    <updated>2018-10-15T08:51:11.220Z</updated>
    
    <summary type="html">
    
      Relation Extraction Summary.
    
    </summary>
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/tags/Machine-Learning/"/>
    
      <category term="Information Extraction" scheme="http://frankchu0229.github.io/tags/Information-Extraction/"/>
    
      <category term="relation extraction" scheme="http://frankchu0229.github.io/tags/relation-extraction/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-4</title>
    <link href="http://frankchu0229.github.io/2018/10/15/java8-functional-programming4/"/>
    <id>http://frankchu0229.github.io/2018/10/15/java8-functional-programming4/</id>
    <published>2018-10-15T07:41:32.000Z</published>
    <updated>2018-10-17T15:22:24.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级集合类和收集器-Collector"><a href="#高级集合类和收集器-Collector" class="headerlink" title="高级集合类和收集器 (Collector)"></a>高级集合类和收集器 (Collector)</h2><p>Java8 除了对Collection类改进之外(增加stream等)，还增加了Collector(收集器)以及Collectors(Collector各种实现的工厂)；方法引用等。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>方法引用可以看作是对lambda表达式的重写，方便对已有方法的重用。方法引用的标准语法为<code>ClassName::methodName</code>, 这里方法后面没有参数，因为不是对方法进行调用。例如对lambda表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">artist -&gt; artist.getName()</div></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Artist::getName</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name -&gt; new Artist(name)</div></pre></td></tr></table></figure><p>等同于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Artist::new</div></pre></td></tr></table></figure><h3 id="元素顺序"><a href="#元素顺序" class="headerlink" title="元素顺序"></a>元素顺序</h3><p>Stream 中的元素以何种顺序进行排列，取决于<code>数据源</code>和<code>对流的操作</code>。</p><ul><li>例如，数据源是List，则流中的出现顺序和list中元素顺序是一致的；如果数据源是<code>HashSet</code>，则流中的元素也是无序的。</li><li>对流的操作，也会对流中元素顺序产生影响</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Integer&gt; list = Stream.of(1,2,3,6,5).sorted().collect(Collectors.toList());</div><div class="line">assertThat(list, hasItem(2)); // assertThat</div></pre></td></tr></table></figure><h3 id="收集器-Collector-amp-amp-Collectors"><a href="#收集器-Collector-amp-amp-Collectors" class="headerlink" title="收集器 Collector &amp;&amp; Collectors"></a>收集器 Collector &amp;&amp; Collectors</h3><p>Stream操作中的collect(及早操作)接收Collector(收集器)，在Collectors中，有一些常用的Collector实现：</p><ul><li>转换为其他集合，<code>Collectors.toList()</code>, <code>Collectors.toSet()</code>；如果想指定Collection类型，可以使用<code>Collectors.toCollection(TreeSet::new)</code></li><li>转换为值，<code>maxBy(comparing(Artist::getCount))</code> 返回数量最大的Artist；<code>averagingInt(Artist::getCount)</code>, <code>summingInt(Artist::getCount)</code>进行相关数值计算，和IntStream等中的操作类似</li><li>数据分块，<code>partitioningBy(Predicate)</code>, 接收一个Predicate操作，将流分成两半，返回Map<boolean, list<artist="">&gt;, 即为true和false两种情况</boolean,></li><li>数据分组，<code>groupingBy(Album::getMusican)</code>, 按照Musician对Album进行分组，返回Map<artist, list<album="">&gt;</artist,></li><li>字符串， <code>Collectors.joining(&quot;,&quot;, &quot;[&quot;, &quot;]&quot;)</code> to join elements in stream with spliter “,”, begin “[“ and end “]”.</li><li>组合收集器 如果我们只想按照艺术家进行分组，但是想返回艺术家的专辑数量，groupingBy支持<code>下游收集器</code>，即<code>groupingBy(Album::getMusican, counting())</code>, 下游收集器会对分组后每块的元素进行相关的操作；同理还可以通过<code>groupingBy(Album::getMusician, mapping(Album::getName, toList()))</code> (mapping作为groupingBy的下游收集器， toList()作为mapping的下游收集器)按照艺术家进行分组，同时可以得到和每个艺术家相关的专辑名列表。</li></ul><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p>Map类在引入lambda表达式之后，也做了相应改变，我们可以通过</p><ul><li><code>computeIfAbsent(key, Function)</code> // 如果不存在, 可以通过Function函数式接口返回其他值</li><li><code>computeIfPresent(key, BiFunction)</code> // 如果存在，可以做相关的BiFunction操作来对map中的值进行修改</li><li><code>compute(key, BiFunction)</code>  // 不判断该key是否存在，可以通过Bifunction对map中的值进行修改等,可以看作是前两者的综合</li></ul><p>我们在对map进行操作的时候，经常会实现这样的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">if (map.contains(key)) &#123;</div><div class="line">    String value = map.get(key);</div><div class="line">    Integer newValue = value + 1;</div><div class="line">    map.put(key, newValue)</div><div class="line">&#125; else &#123;</div><div class="line">    map.put(key, 1);   </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>现在我们可以这样实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();</div><div class="line"></div><div class="line">map.computeIfPresent(key, (key, value) -&gt; value + 1);</div><div class="line">map.computeIfAbsent(key, key -&gt; 1); // OR map.putIfAbsent(key, 1);</div></pre></td></tr></table></figure><p>或者可以通过compute</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, Integer&gt; map = new HashMap(String, Integer);</div><div class="line">map.compute(key, (key, value) -&gt; (value == null) ? 1 : value + 1 );</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li><li><a href="http://blog.tanpeng.net/2017/07/13/map-compute/" target="_blank" rel="external">java8 Map compute</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Vim Config Summary</title>
    <link href="http://frankchu0229.github.io/2018/10/11/vim-config/"/>
    <id>http://frankchu0229.github.io/2018/10/11/vim-config/</id>
    <published>2018-10-11T09:04:44.000Z</published>
    <updated>2018-10-12T06:51:28.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Follow the instructions from <a href="https://github.com/amix/vimrc" target="_blank" rel="external">https://github.com/amix/vimrc</a> to config your vim, you can use basic or awesome config setup.</p><h2 id="Command-Shortcut"><a href="#Command-Shortcut" class="headerlink" title="Command Shortcut"></a>Command Shortcut</h2><p>The leader key mapping is <code>,</code></p><h3 id="NERD-Key-Mappings"><a href="#NERD-Key-Mappings" class="headerlink" title="NERD Key Mappings"></a>NERD Key Mappings</h3><ul><li>map <leader>nn :NERDTreeToggle<cr>, to show the files in the directory. </cr></leader></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/amix/vimrc" target="_blank" rel="external">Vim Config</a></li></ul>]]></content>
    
    <summary type="html">
    
      Vim Config Summary.
    
    </summary>
    
      <category term="vim" scheme="http://frankchu0229.github.io/categories/vim/"/>
    
    
      <category term="notes" scheme="http://frankchu0229.github.io/tags/notes/"/>
    
      <category term="vim" scheme="http://frankchu0229.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning Metrics</title>
    <link href="http://frankchu0229.github.io/2018/10/11/ml-metrics/"/>
    <id>http://frankchu0229.github.io/2018/10/11/ml-metrics/</id>
    <published>2018-10-11T09:03:20.000Z</published>
    <updated>2019-04-06T11:47:07.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>这里总结下机器学习中常见任务评价指标的计算方式以及他们代表的含义。通常线上使用的是业务指标，如点击率(CTR),转化率(CVR)等，线下使用机器学习指标，根据机器学习任务类型，可以分为分类指标，回归指标，聚类指标，排序指标等。</p><h2 id="分类指标"><a href="#分类指标" class="headerlink" title="分类指标"></a>分类指标</h2><p>在<a href="http://frankchu.tech/2016/04/07/ML3/" target="_blank" rel="external">Model Selection and Evaluation</a>中，我们介绍了Accuracy, Precision，Recall，F1，\( F_{\beta}\)，confusion matrix(混淆矩阵)，这里我们补充下 <code>ROC</code>, <code>AOC</code>， <code>PR Curve</code>, <code>Macro Precision</code>, <code>Micro Precision</code></p><h3 id="PR-Curve"><a href="#PR-Curve" class="headerlink" title="PR Curve"></a>PR Curve</h3><p>以Precision为纵轴，Recall为横轴，根据分类threshold不同取值，绘制PR曲线，PR曲线越靠右上代表模型性能越好。</p><h3 id="ROC-与-AUC"><a href="#ROC-与-AUC" class="headerlink" title="ROC 与 AUC"></a>ROC 与 AUC</h3><p>在介绍ROC(Receiver Operating Characteristic)之前，我们先介绍TPR(真正率)和FPR(假正率).</p><p>$$ TPR = \frac{TP}{TP+FN} $$<br>$$ FPR = \frac{FP}{TN+FP} $$</p><p>ROC曲线就是以 TPR为纵坐标，FPR为横坐标，根据分类threshold的不同而做的曲线，而曲线下的面积即为AOC<br>(Area Under ROC Curve). </p><p>ROC 曲线越靠近左上角表示模型性能越好，最好情况为(0, 1)点，即TPR = 1, FPR = 0, 进而推算出FN = 0， FP=0, 即全部预测正确。</p><h3 id="对数损失-Logistic-Loss"><a href="#对数损失-Logistic-Loss" class="headerlink" title="对数损失 (Logistic Loss)"></a>对数损失 (Logistic Loss)</h3><p>在<a href="Linear Models for Classification">Linear Models for Classification</a>中，我们介绍二分类和多分类的对数损失即</p><p>$$ logloss = - \frac{1}{N} \sum_{i=1}^{N} (y\log p_i + (1-y) \log(1-p_i))$$</p><p>$$ logloss = - \frac{1}{N} \frac{1}{C} \sum_{i=1}^{N} \sum_{j=1}^{C} y_{ij} \log p_{ij}$$</p><h3 id="Micro-Precison-与-Macro-Precision"><a href="#Micro-Precison-与-Macro-Precision" class="headerlink" title="Micro Precison 与 Macro Precision"></a>Micro Precison 与 Macro Precision</h3><p>对于多分类的Precision的计算有两种方式，一种是Macro Precision， 一种是Micro Precision</p><p>Macro-Precision 对每一类计算Precision， 然后将这些类的Precision计算平均值，得到macro-precision </p><p>Micro-Precision将每一类的(TP), (TP + FP)添加到相应的分子，分母中，然后用总的<br>$$ Micro-Precision = \frac{TP_A}{TP_A + FP_A} $$</p><p>相应的macro-recall， micro-recall 也通过类似的方式进行计算。</p><p><a href="https://datascience.stackexchange.com/questions/15989/micro-average-vs-macro-average-performance-in-a-multiclass-classification-settin" target="_blank" rel="external">Ref</a></p><h2 id="回归指标"><a href="#回归指标" class="headerlink" title="回归指标"></a>回归指标</h2><p>在<a href="http://frankchu.tech/2016/04/07/ML3/" target="_blank" rel="external">Model Selection and Evaluation</a>, 我们介绍了<code>MSE</code>, 常用的回归指标还有 </p><ul><li><code>RMSE</code>  \( RMSE = \sqrt(MSE) \)</li><li><code>MAE</code>   \( MAE = \frac{1}{N} \sum_{i=1}^{N} |f(x_i) - y_i|\)</li></ul><h2 id="排序指标"><a href="#排序指标" class="headerlink" title="排序指标"></a>排序指标</h2><p>在排序中，Precision， Recall， Accuracy， F1等指标也可以使用，但是这些指标没有考虑rank的顺序，在排序中常用的指标还有<code>MAP</code>, <code>MRR</code>, <code>NDCG</code>, <code>P@N</code>等</p><h3 id="P-N"><a href="#P-N" class="headerlink" title="P@N"></a>P@N</h3><p>Precision@N 的计算方式很简单，即对rank 出来的topN计算Precision。</p><h3 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h3><p>Mean Average Precision(平均准确率), 的公式分为两部分组成，先计算个体的平均准确率(Average Precision), 然后计算整体的平均准确率.</p><p>$$ AP@K = \frac{\sum_{k=1}^{\min_{(M, K)} P(k) Rel(k)}}{\min_{(M, K)}} $$</p><p>$$MAP@K = \sum_{q=1}^{Q} \frac{AP@K}{Q} $$</p><p>其中，M为IR返回的文档个数，K为要计算指标的文档个数， P(k)表示前k文档中的precision， rel(k)表示第k个文档和用户query是否相关。<code>MAP中的相关性只能用0，1表示</code>。</p><h3 id="MRR"><a href="#MRR" class="headerlink" title="MRR"></a>MRR</h3><p>Mean Reciprocal Rank(MRR)是常被用在QA和IR系统中的指标，它只关心正确的答案在rank出文档列表中的位置，不关心其他文档的出现位置，相应的， </p><p>$$ MRR = \frac{1}{Q} \sum_{i=1}^{Q} \frac{1}{rank_i}$$</p><h3 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h3><p>Normalized Discounted Cumulative Gain(NDCG)是排序中经常用到的指标之一， 可以通过以下公式来计算：</p><p>$$ CG@K = \sum_{k=1}^{K} rel_k$$<br>$$ DCG@K = \sum_{k=1}^{K} \frac{2^{rel_k}-1}{\log_{2}^{k+1}}$$ DCG@K在CG@K的基础上引入了rank顺序惩罚<br>$$ IDCG@K = \sum_{k=1}^{|REL|} \frac{2^{rel_k} - 1}{\log_{2}^{k + 1}} $$ IDCG@K 方便query之间进行比较，引入的normalization项，I(Ideal)指的是按照relevance从大到小的顺序进行排序，计算相应的DCG@K的值。<br>$$ NDCG@K = \frac{DCG@K}{IDCG@K}$$</p><p>NDCG@K中的相关性可以有多个值，比如{1,2,3,4,5}等。</p><hr><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://en.wikipedia.org/wiki/Evaluation_measures_(information_retrieval" target="_blank" rel="external">IR Evaluation Metrics</a>)</li><li><a href="https://en.wikipedia.org/wiki/Discounted_cumulative_gain" target="_blank" rel="external">NDCG</a></li><li><a href="http://www.ituring.com.cn/book/2573" target="_blank" rel="external">美团机器学习实践</a></li><li><a href="https://blog.csdn.net/shenxiaoming77/article/details/72627882" target="_blank" rel="external">CSDN Blog</a></li><li><a href="https://en.wikipedia.org/wiki/Mean_reciprocal_rank" target="_blank" rel="external">MRR</a></li><li><a href="https://zhuanlan.zhihu.com/p/38850753" target="_blank" rel="external">From zhihu</a></li><li><a href="http://cs.nju.edu.cn/zhouzh/zhouzh.files/publication/MLbook2016.htm" target="_blank" rel="external">机器学习</a></li></ul><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>]]></content>
    
    <summary type="html">
    
      Machine Learning Metrics Summary.
    
    </summary>
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/tags/Machine-Learning/"/>
    
      <category term="metrics" scheme="http://frankchu0229.github.io/tags/metrics/"/>
    
  </entry>
  
  <entry>
    <title>QA Summary</title>
    <link href="http://frankchu0229.github.io/2018/10/11/qa-summary/"/>
    <id>http://frankchu0229.github.io/2018/10/11/qa-summary/</id>
    <published>2018-10-11T07:15:05.000Z</published>
    <updated>2018-10-11T07:18:14.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://www.chinahadoop.cn/" target="_blank" rel="external">知识图谱 From HaoFen Wang</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.chinahadoop.cn/&quot;
      
    
    </summary>
    
      <category term="Query Answering Summary." scheme="http://frankchu0229.github.io/categories/Query-Answering-Summary/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="kg" scheme="http://frankchu0229.github.io/tags/kg/"/>
    
      <category term="qa" scheme="http://frankchu0229.github.io/tags/qa/"/>
    
  </entry>
  
  <entry>
    <title>Knowledge Representation Summary</title>
    <link href="http://frankchu0229.github.io/2018/10/08/kr-summary/"/>
    <id>http://frankchu0229.github.io/2018/10/08/kr-summary/</id>
    <published>2018-10-08T05:22:34.000Z</published>
    <updated>2018-10-11T07:18:15.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识表示"><a href="#知识表示" class="headerlink" title="知识表示"></a>知识表示</h2><h3 id="RDF"><a href="#RDF" class="headerlink" title="RDF"></a>RDF</h3><p>三元组, 表达能力有限。</p><h3 id="RDFS"><a href="#RDFS" class="headerlink" title="RDFS"></a>RDFS</h3><p>在RDF的基础上，添加了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class, subClassOf, type, Property, subPropertyOf, Domain, Range</div></pre></td></tr></table></figure><p>Examples:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">:hasCharacteristic a rdfs:Property ;</div><div class="line">                   rdfs:domain :Person .</div><div class="line"></div><div class="line">:hasHeightInInches rdfs:subPropertyOf :hasCharacteristics ;</div><div class="line">                   rdfs:domain xsd:int .</div><div class="line"></div><div class="line">:hasName           rdfs:subPropertyOf :hasCharacteristic ;</div><div class="line">                   rdfs:domain xsd:string .</div></pre></td></tr></table></figure><p>Property、subProperty在ontology层出现。</p><h3 id="OWL-词汇"><a href="#OWL-词汇" class="headerlink" title="OWL 词汇"></a>OWL 词汇</h3><p>OWL 在RDFS基础上，在ontology层面增加了更多的关系种类，如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">exp:运动员 owl:equivalentClass exp:体育选手 </div><div class="line">exp:获得 owl:equivalentProperty exp:取得</div><div class="line">exp:运动员A owl:sameIndividualAs exp:小明</div><div class="line">exp:ancestor rdf:type owl:TransitiveProperty</div><div class="line">exp:ancestor owl:inverseOf exp:descendant</div><div class="line">exp:hasMother rdf:type owl:FunctionalProperty // 每个人只有一个母亲</div><div class="line">exp:friend rdf:type owl:SymmetricProperty</div><div class="line">...</div></pre></td></tr></table></figure><h3 id="JsonLD"><a href="#JsonLD" class="headerlink" title="JsonLD"></a>JsonLD</h3><p>JsonLD 是一 种基于JSON表示和传输互联数据 (Linked Data)的方法, 在java、python等语言中，都有对jsonld的解析lib。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">&quot;http://schema.org/name&quot;: &quot;Manu Sporny&quot;,</div><div class="line">&quot;http://schema.org/url&quot;: &#123; &quot;@id&quot;:&quot;http://manu.sporny.org/&quot; &#125;, &quot;http://schema.org/image&quot;: &#123; &quot;@id&quot;:&quot;http://manu.sporny.org/images/manu.png&quot; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>还有RDFa等，算是对知识的一种新型表示方法。</p><h3 id="各种典型知识图谱项目中的知识表示"><a href="#各种典型知识图谱项目中的知识表示" class="headerlink" title="各种典型知识图谱项目中的知识表示"></a>各种典型知识图谱项目中的知识表示</h3><h4 id="WordNet"><a href="#WordNet" class="headerlink" title="WordNet"></a>WordNet</h4><ul><li>linguistic 图谱</li><li>词之间语言学关系 (同义词、反义词、上位词、下位词)</li></ul><p>中文词汇网路 (Chinese Wordnet, 以下简称中文词网) 计画，目的是在提供完整的中文词义 (sense) 区分与词汇语意关系知识库。相信词义的区分与表达，必须建立在完善的词汇语意学 (lexical semantics) 理论与知识本体 (ontology) 架构基础上。在词义理论与认知研究方面，这个详细分析的词汇知识库系统，将成為语言学研究的基本参考资料。在实际的应用上，这个资料库可望成為中文语言处理与知识工程不可或缺的基底架构。</p><p>本计划自 2003 年起，迄今累积了近十年的研究成果，对词义区分定义，与词义知识表达方式，渐次做了修正。建构过程中，也曾发表於国内外相关研究机关与数个国际研讨会议，得到了许多有价值的建议。中文词网的网路搜寻介面，在 2006 年於中央研究院语言学研究所正式啟用，提供给各界检索使用。到 2010 计画执行结束前，网站资料与技术报告内容皆作同步更新。为了永续经营此项珍贵的中文词汇资源，目前计画网站转由国立台湾大学语言学研究所维护。</p><h4 id="DbPedia-amp-amp-CN-Depedia"><a href="#DbPedia-amp-amp-CN-Depedia" class="headerlink" title="DbPedia &amp;&amp; CN-Depedia"></a>DbPedia &amp;&amp; CN-Depedia</h4><p>百科知识图谱<br>CN-Depedia 整合了如百度百科、互动百科、中文维基百科等百科网站</p><h4 id="YAGO"><a href="#YAGO" class="headerlink" title="YAGO"></a>YAGO</h4><p> 多语言知识库，包含中文。</p><p>YAGO是由德国马普研究所研制的链接数据库。YAGO主要集成了Wikipedia、WordNet和GeoNames三个来源的数据。YAGO将WordNet的词汇定义与Wikipedia的分类体系进行了融合集成，使得YAGO具有更加丰富的实体分类体系。YAGO还考虑了时间和空间知识，为很多知识条目增加了时间和空间维度的属性描述。目前，YAGO包含1.2亿条三元组知识。YAGO是IBM Watson的后端知识库之一。</p><h4 id="Probase-amp-amp-CN-Probase"><a href="#Probase-amp-amp-CN-Probase" class="headerlink" title="Probase &amp;&amp; CN-Probase"></a>Probase &amp;&amp; CN-Probase</h4><ul><li>通用概念知识图谱    </li><li>包含约1700万实体、27万概念和3300万isa关系。</li><li>schema: Class, Entity, Property:isA (only), </li></ul><h4 id="FreeBase"><a href="#FreeBase" class="headerlink" title="FreeBase"></a>FreeBase</h4><p>类似于wikidata，由社区等众包而成，</p><p>Freebase is built on the notions of objects, facts, types, and properties. Each Freebase object has a stable identifier called a “mid” (for Machine ID), one or more types, and uses properties from these types in order to provide facts. For example, the Freebase object for Barack Obama has the mid /m/02mjmr and the type /government/us_president (among others) that allows the entity to have a fact with the property /government/us_president/presidency_number and the literal integer “44” as the value. </p><p>Freebase uses Compound Value Types (CVTs) to represent n-ary relations with n &gt; 2, e.g., values like geographic coordinates, political positions held with a start and an end date (see Figure 1 for an example), or actors playing a character in a movie. CVT values are just objects, i.e., they have a mid and can have types (although they usually only have the compound value type itself). Most non-CVT objects are called topics in order to discern them from CVTs.</p><p>The content of Freebase has been partially imported from various sources such as Wikipedia [1] or the license-compatible part of MusicBrainz [30]. Over the years, the Freebase community and Google have maintained the knowledge base. When Freebase was turned read-only on March 31, 2015, it counted more than 3 billion facts about almost 50 million entities. Freebase data is published as an N-Triples dump in RDF [6] under the Creative Commons CC-BY license.</p><h4 id="zhishi-me"><a href="#zhishi-me" class="headerlink" title="zhishi.me"></a>zhishi.me</h4><ul><li>百科知识图谱(中文百科，百度百科，互动百科)</li><li>通用领域知识图谱</li></ul><p><a href="http://zhishi.me/" target="_blank" rel="external">Zhishi.me</a> 通过从开放的百科数据中抽取结构化数据，首次尝试构建中文通用知识图谱。目前，已融合了三大中文百科，百度百科，互动百科以及维基百科中的数据。</p><h4 id="WikiData"><a href="#WikiData" class="headerlink" title="WikiData"></a>WikiData</h4><p>WikiData的目标是构建一个免费开放、多语言、任何人或机器都可以编辑修改的大规模链接知识库。WikiData由维基百科于2012年启动，早期得到微软联合创始人Paul Allen、Gordon Betty Moore基金会以及Google的联合资助。WikiData继承了Wikipedia的众包协作的机制，但与Wikipedia不同，WikiData支持的是以三元组为基础的知识条目（Items）的自由编辑。一个三元组代表一个关于该条目的陈述（Statements）。例如可以给“地球”的条目增加“”的三元组陈述。截止2016年，WikiData已经包含超过2470多万个知识条目。</p><p>Wikidata’s data model relies on the notions of item and statement. An item represents an entity, has a stable identifier called “qid”, and may have labels, descriptions, and aliases in multiple languages; further statements and links to pages about the entity in other Wikimedia projects—most prominently Wikipedia. Contrary to Freebase, Wikidata statements do not aim to encode true facts, but claims from different sources, which can also contradict each other, which, for example, allows for border conflicts to be expressed from different political points of view.</p><p><strong>中文dump <a href="http://openkg.cn/dataset/zhonto" target="_blank" rel="external">zh-onto</a></strong></p><h4 id="BabelNet"><a href="#BabelNet" class="headerlink" title="BabelNet"></a>BabelNet</h4><p><strong>多语言词典知识库</strong></p><p>BabelNet是类似于WordNet的多语言词典知识库。BabelNet的目标是解决WordNet在非英语语种中数据缺乏的问题。BabelNet采用的方法是将WordNet词典与Wikipedia百科集成。首先建立WordNet中的词与Wikipedia的页面标题的映射，然后利用Wikipedia中的多语言链接，再辅以机器翻译技术，来给WordNet增加多种语言的词汇。BabelNet3.7包含了271种语言，1400万同义词组，36.4万词语关系和3.8亿从Wikipedia中抽取的链接关系，总计超过19亿RDF三元组。 BabelNet集成了WordNet在词语关系上的优势和Wikipedia在多语言语料方面的优势，构建成功了目前最大规模的多语言词典知识库。</p><h4 id="ConceptNet"><a href="#ConceptNet" class="headerlink" title="ConceptNet"></a>ConceptNet</h4><p><strong>多语言常识知识库</strong></p><p>ConceptNet是常识知识库。最早源于MIT媒体实验室的Open Mind Common Sense (OMCS)项目。OMCS项目是由著名人工智能专家Marvin Minsky于1999年建议创立。ConceptNet主要依靠互联网众包、专家创建和游戏三种方法来构建。ConceptNet知识库以三元组形式的关系型知识构成。ConceptNet5版本已经包含有2800万关系描述。与Cyc相比，ConceptNet采用了非形式化、更加接近自然语言的描述，而不是像Cyc那样采用形式化的谓词逻辑。与链接数据和谷歌知识图谱相比，ConceptNet比较侧重于词与词之间的关系。从这个角度看，ConceptNet更加接近于WordNet，但是又比WordNet包含的关系类型多。此外，ConceptNet完全免费开放，并支持多种语言。</p><p>Cyc的扩展</p><h4 id="NELL"><a href="#NELL" class="headerlink" title="NELL"></a>NELL</h4><p>openIE的一种</p><h4 id="Schema-org-amp-amp-CN-Schema"><a href="#Schema-org-amp-amp-CN-Schema" class="headerlink" title="Schema.org &amp;&amp; CN-Schema"></a>Schema.org &amp;&amp; CN-Schema</h4><p><a href="http://cnschema.org/" target="_blank" rel="external">cnSchema.org</a>是一个基于社区维护的开放的知识图谱Schema标准。cnSchema的词汇集包括了上千种概念分类(classes)、数据类型(data types)、属性(propertities)和关系(relations)等常用概念定义，以支持知识图谱数据的通用性、复用性和流动性。结合中文的特点，我们复用、连接并扩展了<a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>，Wikidata， Wikipedia等已有的知识图谱Schema标准，为中文领域的开放知识图谱、聊天机器人、搜索引擎优化等提供可供参考和扩展的数据描述和接口定义标准。通过cnSchema, 开发者也可以快速对接上百万基于<a href="http://schema.org/" target="_blank" rel="external">Schema.org</a>定义的网站，以及Bot的知识图谱数据API。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://openkg.cn/home" target="_blank" rel="external">OpenKG</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/44818.pdf" target="_blank" rel="external">From Freebase to Wikidata: The Great Migration</a></li></ul>]]></content>
    
    <summary type="html">
    
      Knowledge Representation Summary.
    
    </summary>
    
      <category term="Knowledge Graph" scheme="http://frankchu0229.github.io/categories/Knowledge-Graph/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="kg" scheme="http://frankchu0229.github.io/tags/kg/"/>
    
      <category term="kr" scheme="http://frankchu0229.github.io/tags/kr/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-3</title>
    <link href="http://frankchu0229.github.io/2018/10/07/java8-functional-programming3/"/>
    <id>http://frankchu0229.github.io/2018/10/07/java8-functional-programming3/</id>
    <published>2018-10-07T03:05:47.000Z</published>
    <updated>2018-10-28T13:35:40.490Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类库"><a href="#类库" class="headerlink" title="类库"></a>类库</h2><p>Java8 中另一个变化是引入了接口的默认方法和接口的静态方法，使得接口中也可以包含代码体了。</p><h3 id="对基本类型进行优化的Stream"><a href="#对基本类型进行优化的Stream" class="headerlink" title="对基本类型进行优化的Stream"></a>对基本类型进行优化的Stream</h3><p>在java中，类型可以分为基本类型和装箱类型，例如，int为基本类型，Integer为装箱类型。基本类型内建在语言和运行环境中，是程序构建的基本模块；装箱类型属于普通的java类，为对基本类型的一种封装。Java中范型可以看作是对范型参数类型的擦除，即假设他是Object的实例，因此只有装箱类型才能作为范型参数。这就解释了为什么声明一个<code>List&lt;int&gt;</code>的列表，得到的却是<code>List&lt;Integer&gt;</code>的列表，即包含了整型对象的列表。 将基本类型转换为装箱类型为<code>装箱</code>操作，将装箱类型转换为基本类型为<code>拆箱</code>操作。</p><p>装箱类型是普通的java class对象，装箱类型在存储和计算上有着相关的缺陷：</p><ul><li>在存储上，由于装箱类型是对象，因此相比基本类型存在更大的内存开销 (指向对象的指针等存储开销)</li><li>基本类型和装箱类型之间的装箱和拆箱操作会引入额外的计算开销</li></ul><p>对于会涉及到大量数值运算的算法来说，装箱、拆箱操作以及装箱类型引入的额外内存存储，都会对程序运行性能造成一定的影响。</p><p>因此，Stream中的某些方法对基本类型和装箱类型做了区分。在java8中只对<code>int</code>, <code>long</code> 和<code>double</code>类型做了特殊处理，因为它们在数值运算中用到的比较多，经过特殊处理之后，系统性能提升明显。</p><h4 id="Best-Practice-用Stream做数值运算"><a href="#Best-Practice-用Stream做数值运算" class="headerlink" title="Best Practice: 用Stream做数值运算"></a>Best Practice: 用Stream做数值运算</h4><ul><li>如果Collection包含的已经为<code>int</code>, <code>long</code>, <code>double</code>基础类型数据，那么创建<code>IntStream</code>,<code>LongStream</code>, <code>DoubleStream</code> ASAP</li><li>如果Collection为其他类型，那么在做完filter等操作之后，尽快使用<code>mapToInt</code>, <code>mapToLong</code>, <code>mapToDouble</code>, 将stream转换为相应的<code>IntStream</code>,<code>LongStream</code>, <code>DoubleStream</code>. </li></ul><h4 id="几种命名Convention"><a href="#几种命名Convention" class="headerlink" title="几种命名Convention"></a>几种命名Convention</h4><ul><li><code>ToLongFunction</code>, R -&gt; long, 如果为int、long、double，则可以使用相应的<code>LongToIntFunction</code>, <code>LongToDoubleFunction</code></li><li><code>mapToLong</code> 接收<code>ToLongFunction</code>, 相应的，在IntStream中, <code>mapToLong</code>方法接收<code>IntToLongFunction</code>函数式接口。</li></ul><h3 id="重载解析"><a href="#重载解析" class="headerlink" title="重载解析"></a>重载解析</h3><p>在java中，相同方法名，不同参数类型的方法可以被重载。但重载可能会对类型推断造成影响，因为可能会有多种类型被推断出来，javac会选择<code>最具体的</code>那种类型作为推断结果；然而有的时候推断<code>最具体的</code>类型可能会有问题，这时javac会报错。例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line"></div><div class="line">  interface TestPredicate extends Predicate &#123;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void overLoad(Predicate predicate) &#123;</div><div class="line">    System.out.println(&quot;Predicate&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void overLoad(TestPredicate predicate) &#123;</div><div class="line">    System.out.println(&quot;TestPredicate&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void test(Object object) &#123;</div><div class="line">    System.out.println(&quot;Object&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void test(String string) &#123;</div><div class="line">    System.out.println(&quot;string&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    Demo demo = new Demo();</div><div class="line">    demo.test(&quot;ss&quot;);</div><div class="line">    demo.overLoad(x -&gt; false);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>但是当TestPredicate 不是Predicate的子类时，javac会找到多个类型推断的结果，进而报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line"></div><div class="line">  interface TestPredicate&lt;T&gt; &#123;</div><div class="line">    boolean test(T t);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void overLoad(Predicate predicate) &#123;</div><div class="line">    System.out.println(&quot;Predicate&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void overLoad(TestPredicate predicate) &#123;</div><div class="line">    System.out.println(&quot;TestPredicate&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void test(Object object) &#123;</div><div class="line">    System.out.println(&quot;Object&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public void test(String string) &#123;</div><div class="line">    System.out.println(&quot;string&quot;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  public static void main(String[] args) &#123;</div><div class="line">    Demo demo = new Demo();</div><div class="line">    demo.test(&quot;ss&quot;);</div><div class="line">    demo.overLoad(x -&gt; false); // ambiguous method call. </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因此，在方法重载和类型推断中，</p><ul><li>如果只有一种方法，则javac会推断出相关类型</li><li>如果有多个方法，则javac会选出<code>最具体的</code>那种类型</li><li>如果推断出多个类型，javac会报错，此时需要人为制定类型。</li></ul><h3 id="FunctionalInterface"><a href="#FunctionalInterface" class="headerlink" title="@FunctionalInterface"></a>@FunctionalInterface</h3><p>在定义函数式接口的时候，最好在前面加上<code>@FunctionalInterface</code>注解，这样方便使用方清楚它是一个函数式接口，在重构的时候，如果改成多个方法，javac就会报错。值得一提的是，在java中只有一个方法的接口，并不一定是想使用lambda表达式来实现的，比如<code>Closable</code>和<code>Comoparable</code>接口都只有一个方法，这种属于纯属巧合。</p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>二进制兼容是java的一大特性，Java8中最大的修改是在Collection接口增加了stream等方法，这意味者所有实现了Collection的接口都要实现stream()等的方法。java核心库可以做相关的实现，但是在核心库之外的实现了Collection接口的类就不能二进制兼容了，为了解决这个问题，java8中引入了<code>default</code>接口。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">所谓“二进制兼容性”指的就是在升级（也可能是 bug fix）库文件的时候，不必重新编译使用这个库的可执行文件或使用这个库的其他库文件，程序的功能不被破坏</div></pre></td></tr></table></figure><p>相应的在Java8中，Iterable中也增加了foreach的default接口。</p><p><strong>接口是一种约定方式，接口中的成员变量都是静态的，即默认修饰符public static final的；成员方法都是抽象的，即默认此时符 public abstract</strong></p><p>默认方法不对子类进行假设，用子类的实现来覆盖默认方法的实现方式。当类中实现方法和接口中的默认方法冲突时，<code>类中重写方法胜出</code>，这是由默认方法的提出主要是为了解决向后兼容的问题导致的。</p><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>在java8之前，java不支持“实现多继承”，但是支持“声明多继承”，即<code>不允许类继承多个父类，只允许继承一个父类</code>；但是允许<code>实现多个接口，同时一个接口可以继承多个父接口</code>。在java8之前，接口中只有方法的定义，没有方法的实现，但是在java8中引入默认方法之后，进而提供了某种程度上“实现多继承”的实现方式。但是通过接口的默认方法实现的多重继承，只能实现代码的多重继承，不能实现状态的多重继承(没有成员变量等的继承)；抽象类的继承可以有状态继承，但只能继承一个父类。</p><p>相应的，我们来看下多重继承。我们知道，接口允许多重继承，当两个接口中都有相同的默认方法时，需要相关的类进行相关的方法实现，不然编译器会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">interface World &#123;</div><div class="line"></div><div class="line">  default void test() &#123;</div><div class="line">    System.out.println(&quot;World&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">interface Hello &#123;</div><div class="line">  default void test() &#123;</div><div class="line">    System.out.println(&quot;Hello&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Demo implements Hello, World&#123;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void test() &#123;</div><div class="line">    Hello.super.test(); // 增强的super写法</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="三定律"><a href="#三定律" class="headerlink" title="三定律"></a>三定律</h4><p>对于默认方法的工作原理，以及在多重继承下的行为，我们可以通过以下三定律来进行思考：</p><ul><li><code>类胜于接口</code></li><li><code>子类胜于父类</code> </li><li>如果用了以上方法，但是继承行为仍有冲突或不明，则需要在子类中实现该方法，或者将该方法定义为抽象方法。</li></ul><h3 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h3><p>Optional 作为对null的代替，是java8中引入的一种新的数据类型。null会引起<code>NullPointerException</code>，会导致程序崩溃，这引起了很多人的抱怨。Optional引入的目的主要为鼓励程序员适时检查代码是否为空，以避免代码缺陷。</p><h4 id="Optional使用"><a href="#Optional使用" class="headerlink" title="Optional使用"></a>Optional使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">## Optional Factory</div><div class="line"></div><div class="line">Optional.of()</div><div class="line">Optional.ofNullable()</div><div class="line">Optional.empty()</div><div class="line"></div><div class="line">## Optional Uasge</div><div class="line"></div><div class="line">optional.get() // 需要提前用isPresent判断</div><div class="line">optional.orElse(value) // getOrElse, return the value if present, or return the other value.</div><div class="line">optional.orElseGet(Supplier) // similar to orElse, but suitable for more complicated case.</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li><li><a href="https://www.zhihu.com/question/24317891" target="_blank" rel="external">java多重继承</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-2</title>
    <link href="http://frankchu0229.github.io/2018/10/05/java8-functional-programming2/"/>
    <id>http://frankchu0229.github.io/2018/10/05/java8-functional-programming2/</id>
    <published>2018-10-05T03:05:47.000Z</published>
    <updated>2018-10-07T07:51:42.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Java8 对核心库的更改主要包括对集合类新增API和引入Stream，Stream使得程序员能够在更高的抽象层级上对集合进行操作。</p><p><code>Stream 是函数式编程在集合类上进行复杂操作的工具</code></p><p>先来看一个例子，在java8之前，我们通常会写很多这样的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int count = 0;</div><div class="line">for (Artist artist : Artists) &#123;</div><div class="line">  if (artist.isFrom(&quot;London&quot;)) &#123;</div><div class="line">    ++count;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这种通过for循环的写法，实际上是封装了迭代的语法糖，它属于<code>外部迭代</code>(通过Iterator对象的hasNext和next方法来完成迭代)，等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int count = 0;</div><div class="line">Iterator&lt;Artist&gt; iterator = Artists.iterator();</div><div class="line">while (iterator.hasNext()) &#123;</div><div class="line">  Artist artist = iterator.next();</div><div class="line">  if (artist.isFrom(&quot;London&quot;)) &#123;</div><div class="line">    ++count;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>然而通过外部迭代的方式有以下若干缺陷：</p><ul><li>串行化操作，for循环变成并行方式比较麻烦</li><li>方法和行为混在一起</li></ul><p>我们可以通过<code>内部迭代</code>的方式来实现，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int count = Artists.stream().filter(Artist::isFrom(&quot;London&quot;)).count();</div></pre></td></tr></table></figure><p>这种实现可读性也更好一些。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>在上面的操作中，我们分为过滤和计数两个步骤来进行实现，那么上面基于Stream的方式是怎么实现的呢，是不是比for循环的方式复杂度要高呢？</p><p>在Stream中，操作主要分为：<code>惰性求值</code>和<code>及早求值</code>两种方式。惰性求值返回值仍是stream，而及早求值返回另一个值或者null。Stream中的多个惰性求值操作形成一个惰性求值链，最后由一个及早求值操作返回想要的结果。这也意味着可以有多个级连操作，但是只迭代一次。</p><p>例如，在上面的的例子中，filter就是惰性求值操作，count是及早求值操作。</p><h3 id="常见Stream操作"><a href="#常见Stream操作" class="headerlink" title="常见Stream操作"></a>常见Stream操作</h3><h4 id="惰性求值操作"><a href="#惰性求值操作" class="headerlink" title="惰性求值操作"></a>惰性求值操作</h4><ul><li><p>map 将一种类型的值转变为另一种值, 即接受一个Function<t, r="">的函数式接口</t,></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;).map(String::toUpperCase()).collect(Collectors.toList());</div></pre></td></tr></table></figure></li><li><p>filter 接收一个Predicate<t>, 即输入为T，返回boolean型变量</t></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int count = Artists.stream().filter(Artist::isFrom(&quot;London&quot;)).count();</div></pre></td></tr></table></figure></li><li><p>flatMap flattern Stream of stream and then map, map接收T类型参数，返回Stream，即Function<t, stream=""></t,></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; collected = Stream.of(asList(&quot;a&quot;, &quot;b&quot;), asList(&quot;c&quot;, &quot;d&quot;)).flatMap(List::stream).collect(Collectors.toList());</div></pre></td></tr></table></figure></li><li><p>distinct </p></li><li>limit</li></ul><h4 id="及早求值操作-终止型操作"><a href="#及早求值操作-终止型操作" class="headerlink" title="及早求值操作/终止型操作"></a>及早求值操作/终止型操作</h4><ul><li><p>collect </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; collected = Stream.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // Stream 的of方法使用一组初始值来生成新的Stream</div><div class="line">.collect(Collectoris.toList());</div></pre></td></tr></table></figure></li><li><p>max 传入Comparator T对象, 返回Optional<t></t></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List&lt;Track&gt; tracks = Arrays.asList(new Track(&quot;a&quot;, 524), new Track(&quot;b&quot;, 378, new Track(&quot;c&quot;, 451)));</div><div class="line">Track maxTrack = tracks.stream().max(Comparator.comparing(Track::getLength())).get(); // java8 中，comparing作为工厂方法可以接收一个函数表达式，返回一个Comparator, Comparator有且仅有一个抽象接口，因此为函数式接口。</div></pre></td></tr></table></figure></li><li><p>min</p></li><li>count</li><li><p>reduce 更通用的方式, reduce 可以从一组值中生成一个值，像min，max，count等都属于reduce操作. 对于一组值的迭代，通常可以用以下方式来进行：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object accumulator = initValue;</div><div class="line">for (Object element : collections) &#123;</div><div class="line">  accumulator = combine(accumulator, element)</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><p>在这个计算中，只有initValue和combine是不确定的，因此只需要指定这两个就可以实现一个reduce操作。即reduce操作接收一个初始值和一个BinaryOperator操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int count = Stream.of(1,2,3).reduce(0, (acc, element)-&gt; acc + element );</div></pre></td></tr></table></figure><p>以上例子用reduce实现了一个sum的操作。</p><ul><li>findAny, findFirst, anyMatch, allMatch, forEach</li><li>collect</li></ul><h3 id="正确使用lambda表达式"><a href="#正确使用lambda表达式" class="headerlink" title="正确使用lambda表达式"></a>正确使用lambda表达式</h3><p>lambda表达式的使用应该是<code>无副作用</code>的，即<code>只通过函数返回值就能充分理解函数的作用</code>。</p><ul><li>在lambda表达式内部使用局部变量，该变量应该是<code>既成事实上必须是final的</code></li><li>forEach 方法是一个终结方法，可以有副作用。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Virtualenv Summary</title>
    <link href="http://frankchu0229.github.io/2018/09/27/virtualenv-summary/"/>
    <id>http://frankchu0229.github.io/2018/09/27/virtualenv-summary/</id>
    <published>2018-09-27T06:59:03.000Z</published>
    <updated>2018-09-27T07:08:52.098Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Conda 在使用时还是稍微有些重，virtualenv可以对每一个项目创建一个虚拟环境，然后对每一个项目的python环境进行隔离。</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ul><li><code>pip install virtualenv</code> to install</li><li><code>virtualenv ENV</code> to create virtual env in the directory <code>ENV</code>, which will create <code>bin</code>, <code>lib</code>, <code>include</code>.</li><li><code>source bin/activate</code> to activate the current env.</li><li><code>deactivate</code> to deactivate the current env.</li><li><code>rm -rf ENV</code> to rm the current virtual env.</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://virtualenv.pypa.io/en/stable/" target="_blank" rel="external">User Guide</a></li></ul>]]></content>
    
    <summary type="html">
    
      Virtualenv Summary.
    
    </summary>
    
      <category term="Python Env Management." scheme="http://frankchu0229.github.io/categories/Python-Env-Management/"/>
    
    
      <category term="python" scheme="http://frankchu0229.github.io/tags/python/"/>
    
      <category term="tools" scheme="http://frankchu0229.github.io/tags/tools/"/>
    
      <category term="virtualenv" scheme="http://frankchu0229.github.io/tags/virtualenv/"/>
    
  </entry>
  
  <entry>
    <title>Java8 Functional Programming-1</title>
    <link href="http://frankchu0229.github.io/2018/09/02/java8-functional-programming/"/>
    <id>http://frankchu0229.github.io/2018/09/02/java8-functional-programming/</id>
    <published>2018-09-02T06:54:53.000Z</published>
    <updated>2018-10-07T03:07:56.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ul><li>在Java8之前，java代码的抽象程度不够，同时还欠缺高效的并行操作。</li><li>Java8中引入了lambda表达式，面向对象编程可以看作是对数据进行抽象，而函数式编程是对行为进行抽象，数据与行为并存。</li><li>函数式编程使得编写<code>回调函数</code>和<code>事件处理程序</code>时，不必再纠缠与匿名内部类的弱可读性以及冗繁性。</li><li>增加了default方法，丰富了接口设计中的操作。</li><li>函数式编程核心: 使用不可变值和函数，函数将一个值进行处理，转变为另一个值。</li></ul><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p>Java8 最大的变化就是引入了lambda表达式，一种紧凑的、传递行为的方式。</p><h3 id="Lambda-表达式的几种表达方式"><a href="#Lambda-表达式的几种表达方式" class="headerlink" title="Lambda 表达式的几种表达方式"></a>Lambda 表达式的几种表达方式</h3><ul><li><code>Runnable noArgmants = () -&gt; System.out.println(&quot;Hello World&quot;);</code></li><li><code>ActionListener oneArgument = event -&gt; System.out.println(&quot;button clicked&quot;)</code></li><li><code>Runnable multiStatement = () -&gt; { System.out.println(&quot;Hello&quot;); System.out.println(&quot;World&quot;); }</code></li><li><code>BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y</code> // 参数类型由编译器推断出来</li><li><code>BinaryOperator&lt;Long&gt; add = (Long x, Long y) -&gt; x + y</code> // 显示指定参数类型</li></ul><h3 id="Lambda-表达式引用的是值，而不是变量"><a href="#Lambda-表达式引用的是值，而不是变量" class="headerlink" title="Lambda 表达式引用的是值，而不是变量"></a>Lambda 表达式引用的是值，而不是变量</h3><p>Lambda 表达式引用的是值，而不是变量，即该变量是既成事实上的final，<code>可以不声明为final，但是该变量只能被赋值一次</code>。</p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是指只含有一个抽象方法的接口，用作lambda表达式的类型，用来表示行为。为了表示该接口作为函数式接口来用，最好标识 <code>@FunctionalInterface</code>.</p><p>常用的jdk中提供的函数式接口：</p><ul><li><code>Predict&lt;T&gt;</code> 参数T， 返回boolean</li><li><code>Consumer&lt;T&gt;</code> 参数T， 返回void</li><li><code>Supplier&lt;T&gt;</code> 参数 None， 返回T</li><li><code>Function&lt;T, R&gt;</code> 参数T，返回R</li><li><code>UnaryOperator&lt;T&gt;</code> 参数T， 返回T</li><li><code>BinaryOperator&lt;T, T&gt;</code> 参数T，T 返回T</li></ul><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>在java7中，就有了用菱形操作符来使得javac编译器自动推断类型， 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); // 变量类型推断</div><div class="line">Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;()</div></pre></td></tr></table></figure><p>同样在java7中，将构造函数直接传递给一个方法，编译器可以通过方法签名来做推断，使得泛型可以被省略。<br>java8 更进一步，lambda表达式可以省略所有参数类型。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772" target="_blank" rel="external">Java 8 Lambdas: Functional Programming for the Masses</a></li></ul>]]></content>
    
    <summary type="html">
    
      Java8 Lambdas Functional Programming Summary.
    
    </summary>
    
      <category term="Java" scheme="http://frankchu0229.github.io/categories/Java/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="coding" scheme="http://frankchu0229.github.io/tags/coding/"/>
    
      <category term="java" scheme="http://frankchu0229.github.io/tags/java/"/>
    
      <category term="functional programming" scheme="http://frankchu0229.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>Keras Siamese Network</title>
    <link href="http://frankchu0229.github.io/2018/09/02/keras-siamese-network/"/>
    <id>http://frankchu0229.github.io/2018/09/02/keras-siamese-network/</id>
    <published>2018-09-02T02:11:21.000Z</published>
    <updated>2018-09-02T02:25:26.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>孪生网络 (Siamese Network) 常用在matching等任务上，所谓孪生，是指左右两侧共用同一套网络。</p><h2 id="Implementation-by-Keras"><a href="#Implementation-by-Keras" class="headerlink" title="Implementation by Keras"></a>Implementation by Keras</h2><p>Model Implementation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line"># @Author: Frank Chu</div><div class="line"># @Date: 2018-06-28</div><div class="line"></div><div class="line">from __future__ import print_function</div><div class="line">import numpy as np</div><div class="line">from keras.preprocessing.sequence import pad_sequences</div><div class="line">from keras.models import Model, load_model</div><div class="line">from keras.layers import Dense, Input, Dropout, Embedding, GRU, Bidirectional, \</div><div class="line">    Subtract, Multiply, concatenate, BatchNormalization, Add</div><div class="line">from utils import preprocess, process_embedding_table</div><div class="line">from keras.callbacks import CSVLogger</div><div class="line">import tensorflow as tf</div><div class="line">import keras.backend.tensorflow_backend as KTF</div><div class="line"></div><div class="line"></div><div class="line">class SiameseMatcher:</div><div class="line">    def __init__(self):</div><div class="line">        self._word_vocab_size = 20892</div><div class="line">        self._word_embed_size = 300</div><div class="line">        self._word_sequence_max_length = 15</div><div class="line">        self._char_vocab_size = 3048</div><div class="line">        self._char_embed_size = 300</div><div class="line">        self._char_sequence_max_length = 30</div><div class="line"></div><div class="line">        self._word_embed_path = &apos;../../dataset/word_embed.txt&apos;</div><div class="line">        self._char_embed_path = &apos;../../dataset/char_embed.txt&apos;</div><div class="line">        self._word_corpus_path = &apos;./data/word_corpus.txt&apos;</div><div class="line">        self._char_corpus_path = &apos;./data/char_corpus.txt&apos;</div><div class="line">        self._train_word_data_path = &apos;./data/train_word_data.txt&apos;</div><div class="line">        self._test_word_data_path = &apos;./data/test_word_data.txt&apos;</div><div class="line">        self._train_char_data_path = &apos;./data/train_char_data.txt&apos;</div><div class="line">        self._test_char_data_path = &apos;./data/test_char_data.txt&apos;</div><div class="line">        self._train_word_query = None</div><div class="line">        self._train_word_answer = None</div><div class="line">        self._train_word_label = None</div><div class="line">        self._test_word_query = None</div><div class="line">        self._test_word_answer = None</div><div class="line"></div><div class="line">        self._word_embed_table = None</div><div class="line">        self._char_embed_table = None</div><div class="line">        self._word_index = None</div><div class="line">        self._char_index = None</div><div class="line"></div><div class="line">        self._batch_size = 256</div><div class="line">        self._epoch = 1</div><div class="line">        self._validation_split = 0.15</div><div class="line">        self._lstm_dim = 256</div><div class="line"></div><div class="line">    def process_train(self):</div><div class="line">        self._word_index, self._train_word_query, \</div><div class="line">        self._train_word_answer, self._train_word_label = preprocess(</div><div class="line">            self._word_corpus_path, self._train_word_data_path,</div><div class="line">            self._word_sequence_max_length, mode=&apos;train&apos;</div><div class="line">        )</div><div class="line">        self._word_embed_table = process_embedding_table(self._word_embed_path,</div><div class="line">                                                         self._word_index)</div><div class="line">        np.save(&apos;./data/word_index&apos;, self._word_index)</div><div class="line">        np.save(&apos;./data/train_word_query&apos;, self._train_word_query)</div><div class="line">        np.save(&apos;./data/train_word_answer&apos;, self._train_word_answer)</div><div class="line">        np.save(&apos;./data/train_word_label&apos;, self._train_word_label)</div><div class="line">        np.save(&apos;./data/word_embed_table&apos;, self._word_embed_table)</div><div class="line">        print(&quot;Preprocess Finished.&quot;)</div><div class="line"></div><div class="line">    def process_test(self):</div><div class="line">        _index, self._test_word_query, \</div><div class="line">        self._test_word_answer, _label = preprocess(</div><div class="line">            self._word_corpus_path, self._test_word_data_path,</div><div class="line">            self._word_sequence_max_length, mode=&apos;test&apos;</div><div class="line">        )</div><div class="line">        np.save(&apos;./data/test_word_query&apos;, self._test_word_query)</div><div class="line">        np.save(&apos;./data/test_word_answer&apos;, self._test_word_answer)</div><div class="line"></div><div class="line">        print(&quot;Test Preprocess Finished.&quot;)</div><div class="line"></div><div class="line">    def build_model(self):</div><div class="line">        query_word_sequence_input = Input(</div><div class="line">            shape=(self._word_sequence_max_length,))</div><div class="line">        answer_word_sequence_input = Input(</div><div class="line">            shape=(self._word_sequence_max_length,))</div><div class="line"></div><div class="line">        word_embedding_layer = Embedding(self._word_vocab_size,</div><div class="line">                                         self._word_embed_size,</div><div class="line">                                         weights=[self._word_embed_table],</div><div class="line">                                         input_length=self._word_sequence_max_length)</div><div class="line">        bi_lstm_layer = Bidirectional(</div><div class="line">            GRU(self._lstm_dim, dropout=0.4, recurrent_dropout=0.2,</div><div class="line">                return_sequences=True))</div><div class="line">        second_lstm_layer = Bidirectional(</div><div class="line">            GRU(self._lstm_dim, dropout=0.4, recurrent_dropout=0.2))</div><div class="line"></div><div class="line">        droupour_layer = Dropout(0.5)</div><div class="line"></div><div class="line">        q1 = word_embedding_layer(query_word_sequence_input)</div><div class="line">        q1 = droupour_layer(q1)</div><div class="line">        q1 = bi_lstm_layer(q1)</div><div class="line">        q1 = second_lstm_layer(q1)</div><div class="line">        q2 = word_embedding_layer(answer_word_sequence_input)</div><div class="line">        q2 = droupour_layer(q2)</div><div class="line">        q2 = bi_lstm_layer(q2)</div><div class="line">        q2 = second_lstm_layer(q2)</div><div class="line">        q_diff = Subtract()([q1, q2])</div><div class="line">        q_mul = Multiply()([q1, q2])</div><div class="line">        q_add = Add()([q1, q2])</div><div class="line">        merged = concatenate([q1, q2, q_add, q_diff, q_mul])</div><div class="line"></div><div class="line">        merged = Dense(256, activation=&apos;relu&apos;)(merged)</div><div class="line">        merged = BatchNormalization()(merged)</div><div class="line">        merged = Dense(256, activation=&apos;relu&apos;)(merged)</div><div class="line">        merged = BatchNormalization()(merged)</div><div class="line">        merged = Dense(128, activation=&apos;relu&apos;)(merged)</div><div class="line">        merged = BatchNormalization()(merged)</div><div class="line">        prediction = Dense(2, activation=&apos;softmax&apos;)(merged)</div><div class="line"></div><div class="line">        model = Model(</div><div class="line">            inputs=[query_word_sequence_input, answer_word_sequence_input],</div><div class="line">            outputs=prediction)</div><div class="line">        model.compile(loss=&apos;categorical_crossentropy&apos;, optimizer=&apos;adam&apos;,</div><div class="line">                      metrics=[&apos;accuracy&apos;])</div><div class="line">        return model</div><div class="line"></div><div class="line">    def train(self):</div><div class="line">        self._word_index = np.load(&apos;./data/word_index.npy&apos;)</div><div class="line">        self._train_word_query = np.load(&apos;./data/train_word_query.npy&apos;)</div><div class="line">        self._train_word_answer = np.load(&apos;./data/train_word_answer.npy&apos;)</div><div class="line">        self._train_word_label = np.load(&apos;./data/train_word_label.npy&apos;)</div><div class="line">        self._word_embed_table = np.load(&apos;./data/word_embed_table.npy&apos;)</div><div class="line">        model = self.build_model()</div><div class="line">        csv_logger = CSVLogger(&apos;log.csv&apos;, append=True, separator=&apos;;&apos;)</div><div class="line">        model.fit([self._train_word_query, self._train_word_answer],</div><div class="line">                  self._train_word_label,</div><div class="line">                  batch_size=self._batch_size, epochs=self._epoch,</div><div class="line">                  validation_split=self._validation_split,</div><div class="line">                  callbacks=[csv_logger])</div><div class="line">        model.save(&apos;./model&apos;)</div><div class="line"></div><div class="line">    def train_all(self, model_path):</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        train the final model using train and dev data.</div><div class="line">        :return:</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        self._word_index = np.load(&apos;./data/word_index.npy&apos;)</div><div class="line">        self._train_word_query = np.load(&apos;./data/train_word_query.npy&apos;)</div><div class="line">        self._train_word_answer = np.load(&apos;./data/train_word_answer.npy&apos;)</div><div class="line">        self._train_word_label = np.load(&apos;./data/train_word_label.npy&apos;)</div><div class="line">        self._word_embed_table = np.load(&apos;./data/word_embed_table.npy&apos;)</div><div class="line">        model = load_model(model_path)</div><div class="line">        model.fit([self._train_word_query, self._train_word_answer],</div><div class="line">                  self._train_word_label,</div><div class="line">                  batch_size=self._batch_size, epochs=self._epoch + 2)</div><div class="line">        model.save(&apos;./final-model&apos;)</div><div class="line"></div><div class="line">    def predict(self, model_path):</div><div class="line">        self._test_word_query = np.load(&apos;./data/test_word_query.npy&apos;)</div><div class="line">        self._test_word_answer = np.load(&apos;./data/test_word_answer.npy&apos;)</div><div class="line">        model = load_model(model_path)</div><div class="line">        prediction = model.predict(</div><div class="line">            [self._test_word_query, self._test_word_answer],</div><div class="line">            batch_size=512)</div><div class="line">        print(prediction)</div><div class="line">        np.save(&apos;./predictions&apos;, prediction)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    model = SiameseMatcher()</div><div class="line">    # model.process_train()</div><div class="line">    # model.process_test()</div><div class="line"></div><div class="line">    config = tf.ConfigProto()</div><div class="line">    config.gpu_options.allow_growth = True  # 不全部占满显存, 按需分配</div><div class="line">    session = tf.Session(config=config)</div><div class="line">    # 设置session</div><div class="line">    KTF.set_session(session)</div><div class="line"></div><div class="line">    model.train()</div></pre></td></tr></table></figure><p>Data Process Implementation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line"># @Author: Frank Chu</div><div class="line"># @Date: 2018-06-28</div><div class="line"></div><div class="line">from keras.preprocessing.text import Tokenizer</div><div class="line">from keras.preprocessing.sequence import pad_sequences</div><div class="line">from keras.utils import to_categorical</div><div class="line">from numpy import asarray, zeros</div><div class="line">import numpy as np</div><div class="line"></div><div class="line"></div><div class="line">def load_file(path):</div><div class="line">    data = list()</div><div class="line">    with open(path, &apos;rt&apos;, encoding=&apos;utf-8&apos;) as fo:</div><div class="line">        for line in fo:</div><div class="line">            data.append(line.strip())</div><div class="line">    return data</div><div class="line"></div><div class="line"></div><div class="line">def preprocess(corpus_path, data_path, max_length, mode=&apos;train&apos;):</div><div class="line">    corpus = load_file(corpus_path)</div><div class="line">    tokenizer = Tokenizer(lower=False)</div><div class="line">    tokenizer.fit_on_texts(corpus)</div><div class="line">    print(tokenizer.word_index)</div><div class="line">    data = load_file(data_path)</div><div class="line">    label, query, answer = process_data_set(data, mode)</div><div class="line">    encoded_query = tokenizer.texts_to_sequences(query)</div><div class="line">    padded_query = pad_sequences(encoded_query, maxlen=max_length,</div><div class="line">                                 padding=&apos;post&apos;)</div><div class="line">    encoded_answer = tokenizer.texts_to_sequences(answer)</div><div class="line">    padded_answer = pad_sequences(encoded_answer, maxlen=max_length,</div><div class="line">                                  padding=&apos;post&apos;)</div><div class="line">    if mode == &apos;train&apos;:</div><div class="line">        label = to_categorical(asarray(label))</div><div class="line"></div><div class="line">    return tokenizer.word_index, padded_query, padded_answer, label</div><div class="line"></div><div class="line"></div><div class="line">def process_data_set(data, mode=&apos;train&apos;):</div><div class="line">    label = []</div><div class="line">    query = []</div><div class="line">    answer = []</div><div class="line">    if mode == &apos;train&apos;:</div><div class="line">        for line in data:</div><div class="line">            splits = line.split(&quot;\t&quot;)</div><div class="line">            label.append(splits[0])</div><div class="line">            query.append(splits[1])</div><div class="line">            answer.append(splits[2])</div><div class="line">    else:</div><div class="line">        for line in data:</div><div class="line">            splits = line.split(&quot;\t&quot;)</div><div class="line">            query.append(splits[0])</div><div class="line">            answer.append(splits[1])</div><div class="line">    return label, query, answer</div><div class="line"></div><div class="line"></div><div class="line">def process_embedding_table(embedding_path, word_index):</div><div class="line">    embedding_data = load_file(embedding_path)</div><div class="line">    splits = embedding_data[0].split(&apos; &apos;)</div><div class="line">    vocab, dim = splits[0], splits[1]</div><div class="line">    print(&quot;vacab size &#123;&#125; and len of embedding data is &#123;&#125;&quot;.format(vocab,</div><div class="line">                                                                 len(</div><div class="line">                                                                     embedding_data)))</div><div class="line">    print(&apos;word index dict size is &#123;&#125;&apos;.format(len(word_index)))</div><div class="line">    # assert vocab == len(word_index)</div><div class="line">    embedding_index = dict()</div><div class="line">    for line in embedding_data:</div><div class="line">        values = line.split(&apos; &apos;)</div><div class="line">        if len(values) == 2:</div><div class="line">            continue</div><div class="line">        word = values[0]</div><div class="line">        vector = asarray(values[1:], dtype=&apos;float32&apos;)</div><div class="line">        embedding_index[word] = vector</div><div class="line"></div><div class="line">    embedding_matrix = zeros((int(vocab) + 1, int(dim)))</div><div class="line">    for word, i in word_index.items():</div><div class="line">        embedding_vector = embedding_index.get(word)</div><div class="line">        if embedding_vector is not None:</div><div class="line">            embedding_matrix[i] = embedding_vector</div><div class="line">        else:</div><div class="line">            print(&apos;word is &#123;&#125; and i is &#123;&#125;&apos;.format(word, i))</div><div class="line">    return embedding_matrix</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://keras.io/zh/" target="_blank" rel="external">keras</a></li></ul>]]></content>
    
    <summary type="html">
    
      Keras Siamese Network.
    
    </summary>
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/categories/Machine-Learning/"/>
    
    
      <category term="python" scheme="http://frankchu0229.github.io/tags/python/"/>
    
      <category term="keras" scheme="http://frankchu0229.github.io/tags/keras/"/>
    
      <category term="dl" scheme="http://frankchu0229.github.io/tags/dl/"/>
    
  </entry>
  
  <entry>
    <title>Semi-supervised Learning And Active Learning Summary</title>
    <link href="http://frankchu0229.github.io/2018/08/20/semi-supervised-learning/"/>
    <id>http://frankchu0229.github.io/2018/08/20/semi-supervised-learning/</id>
    <published>2018-08-20T03:24:06.000Z</published>
    <updated>2018-09-02T05:14:15.019Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在很多场景下(e.g., 业务冷启动)，labelled data是很少的，这时候会去尝试用无监督或者半监督的方式来解决实际中的问题。所谓半监督，就是既用了有标注的数据，又用了未标注的数据。<br>半监督学习和主动学习都是在标注数据少的情况下的一种解决方式。但是我们常说的半监督学习的方式偏向于不需要人工干涉，自动的对未标注数据进行利用。而主动学习(Active Learning)需要外在的相关领域人员进行数据标注，是一个人际协调交互的过程。</p><h2 id="Active-Learning"><a href="#Active-Learning" class="headerlink" title="Active Learning"></a>Active Learning</h2><p>原始数据量是很大的，但是怎么进行标注呢？对所有数据都标注一遍的成本是巨大的。一种方式可以使用<code>主动学习</code>的方式进行标注，减少标注成本。</p><p><code>核心思想</code>：主动学习会选择那些比较难分类的样本，然后由人工进行标注。</p><p><code>步骤</code>:</p><ol><li>从原始数据中随机采样，进行人工标注</li><li>用标注的数据训练分类器，对未标注的数据进行预测</li><li>挑选那些信息量大的样本进行标注， 对于二分类任务，选择那些概率在0.5附近的样本</li><li>重复步骤2和3， 直到 <ul><li>没有更多数据进行标注</li><li>当前分类器性能达到要求</li><li>挑选出来的信息量大的样本，人工无法进行标注</li></ul></li></ol><h2 id="Semi-supervised-Learning"><a href="#Semi-supervised-Learning" class="headerlink" title="Semi-supervised Learning"></a>Semi-supervised Learning</h2><p>Semi-supervised learning 包含的内容比较多，for more info，可以看周志华老师的西瓜书，这里只介绍常用到的自学习和协同学习。</p><h3 id="Self-Learning-自学习-Self-Training"><a href="#Self-Learning-自学习-Self-Training" class="headerlink" title="Self Learning 自学习 (Self Training)"></a>Self Learning 自学习 (Self Training)</h3><p><code>步骤</code></p><ol><li>输入：原始未标注数据，部分标注数据</li><li>用标注数据训练模型, e.g., 分类模型</li><li>用训练好的模型原始数据进行预测</li><li>从预测的数据中选择 最有把握的(e.g., 概率大于0.9) 加入到训练集中，并把他们从未标注数据集中移除</li><li>重复步骤2-4， 直到<ul><li>模型性能达标</li><li>数据集不再变化</li></ul></li></ol><h3 id="Co-Training-协同训练"><a href="#Co-Training-协同训练" class="headerlink" title="Co-Training 协同训练"></a>Co-Training 协同训练</h3><p>Co-training 和self-learning的步骤类似，以下以二分类任务为例：</p><p><code>步骤</code></p><p>该算法假设数据属性拥有两个充分冗余（sufficient and redundant）的视图，称之为 view1 和 view2; view1, view2 一种对用的例子是特征的划分。</p><p>算法基本流程是：</p><ol><li>首先在标记数据集 L 的 view1 和 view2分别上训练出两个分类器 C1 和 C2；</li><li>然后从未标记数据集 U 上随机的选取 u 个示例放入集合 U’中；分别用 C1 和 C2 对 U’中的所有元素进行标记；</li><li>接着从两个分类器标记结果中各取可信度最高的 p 个正标记和 n 个负标记放入 L 中；</li><li>最后从 U 中选取 2p+2n 个数据补充到 U’中；</li><li>重复上述过程直到满足截止条件。</li></ol><p>值得注意的是这两个视图应该是相互独立的。考虑一个极端的情况如果 view1 和 view2 是全相关的，那么由 view1 的到分类器和由 view2 训练得到的分类器对相同待标记示例的标记是完全一样的，这样以来Co-Training 算法就退化成了 self-training 算法。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://lamda.nju.edu.cn/huangsj/dm11/files/gaoy.pdf" target="_blank" rel="external">http://lamda.nju.edu.cn/huangsj/dm11/files/gaoy.pdf</a></li><li><a href="https://blog.csdn.net/u014520745/article/details/45054481" target="_blank" rel="external">https://blog.csdn.net/u014520745/article/details/45054481</a></li><li><a href="https://www.zhihu.com/question/265479171" target="_blank" rel="external">https://www.zhihu.com/question/265479171</a></li><li><a href="https://zhuanlan.zhihu.com/p/29583536" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/29583536</a></li><li><a href="https://blog.csdn.net/qq_35994754/article/details/73457817" target="_blank" rel="external">https://blog.csdn.net/qq_35994754/article/details/73457817</a></li></ul>]]></content>
    
    <summary type="html">
    
      Semi-supervised Learning And Active Learning Summary.
    
    </summary>
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/categories/Machine-Learning/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="ml" scheme="http://frankchu0229.github.io/tags/ml/"/>
    
      <category term="semi-supervised learning" scheme="http://frankchu0229.github.io/tags/semi-supervised-learning/"/>
    
      <category term="active learning" scheme="http://frankchu0229.github.io/tags/active-learning/"/>
    
  </entry>
  
  <entry>
    <title>Kg 2018 Mind Map</title>
    <link href="http://frankchu0229.github.io/2018/08/12/kg-mind-map/"/>
    <id>http://frankchu0229.github.io/2018/08/12/kg-mind-map/</id>
    <published>2018-08-12T03:24:37.000Z</published>
    <updated>2018-10-08T05:25:07.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mind-Map"><a href="#Mind-Map" class="headerlink" title="Mind Map"></a>Mind Map</h2><div align="center"><br><img src="/img/kg_mind_map.png" width="500" height="200" align="center"><br></div><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://mp.weixin.qq.com/s/WdWR_QXNumx_p3uVaoq52w" target="_blank" rel="external">KG 2018 Report</a></li></ul>]]></content>
    
    <summary type="html">
    
      Knowledge Graph Mind Map.
    
    </summary>
    
      <category term="Knowledge Graph" scheme="http://frankchu0229.github.io/categories/Knowledge-Graph/"/>
    
    
      <category term="summary" scheme="http://frankchu0229.github.io/tags/summary/"/>
    
      <category term="kg" scheme="http://frankchu0229.github.io/tags/kg/"/>
    
  </entry>
  
  <entry>
    <title>TF Python Train And Java Serve</title>
    <link href="http://frankchu0229.github.io/2018/08/02/tf-python-train-java-serve/"/>
    <id>http://frankchu0229.github.io/2018/08/02/tf-python-train-java-serve/</id>
    <published>2018-08-02T02:30:59.000Z</published>
    <updated>2018-09-02T03:03:08.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python-Model"><a href="#Python-Model" class="headerlink" title="Python Model"></a>Python Model</h2><p>Convert model to frozen graph with tf, frozen graph cannot be trained again and usually used in production environment.</p><h3 id="1-TF-Add-Name-For-Each-Placeholder"><a href="#1-TF-Add-Name-For-Each-Placeholder" class="headerlink" title="1. TF: Add Name For Each Placeholder"></a>1. TF: Add Name For Each Placeholder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">in_question = tf.placeholder(tf.int32, [None, None], name=&apos;in_question&apos;)  # shape: (batch x seq)</div><div class="line">in_answer = tf.placeholder(tf.int32, [None, None], name=&apos;in_answer&apos;)</div><div class="line">in_question_len = tf.placeholder(tf.int32, [None], name=&apos;in_question_len&apos;)</div><div class="line">in_answer_len = tf.placeholder(tf.int32, [None], name=&apos;in_answer_len&apos;)</div><div class="line">dropout_rate = tf.placeholder(tf.float32, None, name=&apos;dropout_rate&apos;)</div><div class="line">y_prob = tf.nn.softmax(logits, name=&apos;y_pred&apos;)</div></pre></td></tr></table></figure><h3 id="2-Train-and-Save-the-Model-with-SavedModelBuilder"><a href="#2-Train-and-Save-the-Model-with-SavedModelBuilder" class="headerlink" title="2. Train and Save the Model with SavedModelBuilder"></a>2. Train and Save the Model with SavedModelBuilder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">builder = tf.saved_model.builder.SavedModelBuilder(saved_model_dir)</div><div class="line"># x 为输入tensor, keep_prob为dropout的prob tensor</div><div class="line">inputs = &#123;&apos;in_question&apos;: tf.saved_model.utils.build_tensor_info(self.in_question),</div><div class="line">          &apos;in_answer&apos;: tf.saved_model.utils.build_tensor_info(self.in_answer),</div><div class="line">          &apos;in_question_len&apos;: tf.saved_model.utils.build_tensor_info(self.in_question_len),</div><div class="line">          &apos;in_answer_len&apos;: tf.saved_model.utils.build_tensor_info(self.in_answer_len),</div><div class="line">          &apos;in_y&apos;: tf.saved_model.utils.build_tensor_info(self.in_y),</div><div class="line">          &apos;learning_rate&apos;: tf.saved_model.utils.build_tensor_info(self.learning_rate),</div><div class="line">          &apos;dropout_rate&apos;: tf.saved_model.utils.build_tensor_info(self.dropout_rate)&#125;</div><div class="line"></div><div class="line">outputs = &#123;&apos;y_p&apos;: tf.saved_model.utils.build_tensor_info(self.y_p)&#125;</div><div class="line"></div><div class="line">signature = tf.saved_model.signature_def_utils.build_signature_def(inputs, outputs, &apos;test_sig_name&apos;)</div><div class="line"></div><div class="line">builder.add_meta_graph_and_variables(sess, [&apos;baidu-model&apos;], &#123;&apos;signature&apos;: signature&#125;)</div><div class="line">builder.save()</div></pre></td></tr></table></figure><h3 id="3-Choose-the-best-model-and-convert-it-to-frozen-graph"><a href="#3-Choose-the-best-model-and-convert-it-to-frozen-graph" class="headerlink" title="3. Choose the best model and convert it to frozen graph."></a>3. Choose the best model and convert it to frozen graph.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">def convert_to_frozen_graph(path, tags, output_node_names, frozen_path=&apos;./&apos;,</div><div class="line">                            frozen_graph_name=&apos;model.pb&apos;):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    To convert a saved model to a frozen graph. A saved model can be trained,</div><div class="line">    however, a frozen graph cannot be trained again. The model used by java</div><div class="line">    applications is a frozen graph.</div><div class="line">    :param path: saved model path</div><div class="line">    :param tags: saved model tags, set of string tags to identify the</div><div class="line">    required MetaGraphDef.</div><div class="line">    :param output_node_names: List of name strings for the result nodes</div><div class="line">    of the graph.</div><div class="line">    :param frozen_path: frozen graph save path</div><div class="line">    :param frozen_graph_name: frozen graph model name</div><div class="line">    :return: a frozen graph</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    with tf.Session(graph=tf.Graph()) as sess:</div><div class="line">        meta_graph_def = tf.saved_model.loader.load(sess, tags, path)</div><div class="line">        constant_graph = graph_util.convert_variables_to_constants(sess,</div><div class="line">                                                                   sess.graph.as_graph_def(),</div><div class="line">                                                                   output_node_names)</div><div class="line"></div><div class="line">        with tf.gfile.GFile(frozen_path + frozen_graph_name, &apos;wb&apos;) as fw:</div><div class="line">            fw.write(constant_graph.SerializeToString())</div><div class="line">        print(&quot;%d ops in the final graph.&quot; % len(constant_graph.node))</div><div class="line"></div><div class="line"></div><div class="line">def load_frozen_graph(path=&apos;./model.pb&apos;):</div><div class="line">    with tf.gfile.GFile(path, &quot;rb&quot;) as f:</div><div class="line">        graph_def = tf.GraphDef()</div><div class="line">        graph_def.ParseFromString(f.read())</div><div class="line"></div><div class="line">    # We load the graph_def in the default graph</div><div class="line">    with tf.Graph().as_default() as graph:</div><div class="line">        tf.import_graph_def(</div><div class="line">            graph_def,</div><div class="line">            input_map=None,</div><div class="line">            return_elements=None,</div><div class="line">            name=&quot;prefix&quot;,</div><div class="line">            op_dict=None,</div><div class="line">            producer_op_list=None</div><div class="line">        )</div><div class="line">    return graph</div></pre></td></tr></table></figure><h3 id="4-Test-the-frozen-graph"><a href="#4-Test-the-frozen-graph" class="headerlink" title="4. Test the frozen graph"></a>4. Test the frozen graph</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    convert_to_frozen_graph(&apos;../model/x.model&apos;, [&apos;x-model&apos;], [&apos;y_pred&apos;])</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">import tensorflow as tf</div><div class="line">from .utils import load_frozen_graph</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    graph = load_frozen_graph()</div><div class="line">    for op in graph.get_operations():</div><div class="line">        print(op.name, op.values())</div><div class="line"></div><div class="line">    in_question = graph.get_tensor_by_name(&apos;prefix/in_question:0&apos;)</div><div class="line">    in_question_len = graph.get_tensor_by_name(&apos;prefix/in_question_len:0&apos;)</div><div class="line">    in_answer = graph.get_tensor_by_name(&apos;prefix/in_answer:0&apos;)</div><div class="line">    in_answer_len = graph.get_tensor_by_name(&apos;prefix/in_answer_len:0&apos;)</div><div class="line">    dropout_rate = graph.get_tensor_by_name(&apos;prefix/dropout_rate:0&apos;)</div><div class="line">    y_pred = graph.get_tensor_by_name(&apos;prefix/y_pred:0&apos;)</div><div class="line"></div><div class="line">    with tf.Session(graph=graph) as sess:</div><div class="line">        res = sess.run(y_pred,</div><div class="line">                       feed_dict=&#123;</div><div class="line">                           in_question: [</div><div class="line">                               [1935, 1198, 764, 657, 627, 456, 3114, 2964,</div><div class="line">                                137, 2702, 1933, 2003, 634, 137, 643, 3021,</div><div class="line">                                2003, 634, 137, 3177, 967, 2003, 2964, 137,</div><div class="line">                                2729, 240, 2003, 2139, 873, 0, 0, 0, 0, 0, 0]],</div><div class="line">                           in_answer: [</div><div class="line">                               [2300, 2236, 1733, 1206, 2003, 2702, 1933, 456,</div><div class="line">                                3114, 2003, 851, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</div><div class="line">                                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],</div><div class="line">                           in_question_len: [29],</div><div class="line">                           in_answer_len: [11],</div><div class="line">                           dropout_rate: 0</div><div class="line">                       &#125;)</div><div class="line">    print(res)</div></pre></td></tr></table></figure><h2 id="Java-Serve"><a href="#Java-Serve" class="headerlink" title="Java Serve"></a>Java Serve</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">inQuestion = &quot;in_question&quot;;</div><div class="line">inQuestionLen = &quot;in_question_len&quot;;</div><div class="line">inAnswer = &quot;in_answer&quot;;</div><div class="line">inAnswerLen = &quot;in_answer_len&quot;;</div><div class="line">dropoutRate = &quot;dropout_rate&quot;;</div><div class="line">predictSim = &quot;y_pred&quot;;</div><div class="line"></div><div class="line">List&lt;Tensor&lt;?&gt;&gt; res = this.session.runner()</div><div class="line">    .feed(inQuestion, left.get(0)) // left, right are tensors created by tf</div><div class="line">    .feed(inQuestionLen, left.get(1))</div><div class="line">    .feed(inAnswer, right.get(0))</div><div class="line">    .feed(inAnswerLen, right.get(1))</div><div class="line">    .feed(dropoutRate, Tensor.create(0f))</div><div class="line">    .fetch(predictSim)</div><div class="line">    .run();</div><div class="line">res.get(0).copyTo(result);</div></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://docs.google.com/presentation/d/e/2PACX-1vQ6DzxNTBrJo7K5P8t5_rBRGnyJoPUPBVOJR4ooHCwi4TlBFnIriFmI719rDNpcQzojqsV58aUqmBBx/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g306175dd89_0_0" target="_blank" rel="external">https://docs.google.com/presentation/d/e/2PACX-1vQ6DzxNTBrJo7K5P8t5_rBRGnyJoPUPBVOJR4ooHCwi4TlBFnIriFmI719rDNpcQzojqsV58aUqmBBx/pub?start=false&amp;loop=false&amp;delayms=3000&amp;slide=id.g306175dd89_0_0</a></li><li><a href="https://blog.metaflow.fr/tensorflow-how-to-freeze-a-model-and-serve-it-with-a-python-api-d4f3596b3adc" target="_blank" rel="external">https://blog.metaflow.fr/tensorflow-how-to-freeze-a-model-and-serve-it-with-a-python-api-d4f3596b3adc</a></li><li><a href="https://www.tensorflow.org/" target="_blank" rel="external">https://www.tensorflow.org/</a></li></ul>]]></content>
    
    <summary type="html">
    
      Summary for python offline train and java online serve using keras and tensorflow.
    
    </summary>
    
      <category term="Machine Learning" scheme="http://frankchu0229.github.io/categories/Machine-Learning/"/>
    
    
      <category term="python" scheme="http://frankchu0229.github.io/tags/python/"/>
    
      <category term="keras" scheme="http://frankchu0229.github.io/tags/keras/"/>
    
      <category term="dl" scheme="http://frankchu0229.github.io/tags/dl/"/>
    
      <category term="tensorflow" scheme="http://frankchu0229.github.io/tags/tensorflow/"/>
    
  </entry>
  
</feed>
